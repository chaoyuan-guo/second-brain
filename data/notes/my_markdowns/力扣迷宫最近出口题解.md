# åŠ›æ‰£è¿·å®«æœ€è¿‘å‡ºå£é¢˜è§£

## ğŸ§‘â€ğŸ’» User

è®²è§£åŠ›æ‰£é¢˜ç›®1926. è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£

---
## ğŸ¤– Assistant

**ä¸€ã€é¢˜ç›®æœ¬è´¨**

- ç”¨äºŒç»´ç½‘æ ¼è¡¨ç¤ºè¿·å®«ï¼š`'+'` æ˜¯å¢™ï¼Œ`'.'` æ˜¯å¯ä»¥èµ°çš„è·¯
- ç»™ä¸€ä¸ªå…¥å£åæ ‡ `entrance = [r, c]`ï¼ˆä¸€å®šåœ¨ `'.'` ä¸Šï¼‰
- å‡ºå£ï¼š**åœ¨è¾¹ç•Œä¸Šçš„ `'.'` ä¸”ä¸æ˜¯å…¥å£æœ¬èº«**
- æ¯æ¬¡å¯ä»¥ä¸Šä¸‹å·¦å³èµ°ä¸€æ­¥ï¼Œé—®ï¼šåˆ°æœ€è¿‘å‡ºå£çš„**æœ€å°‘æ­¥æ•°**ï¼Œå¦‚æœæ²¡æœ‰å‡ºå£è¿”å› `-1`

è¿™å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„ï¼š**æ— æƒç½‘æ ¼å›¾çš„æœ€çŸ­è·¯é—®é¢˜ â†’ ç”¨ BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰**ã€‚


---

## äºŒã€æ ¸å¿ƒæ€è·¯ï¼ˆä¸ºä»€ä¹ˆç”¨ BFSï¼‰

1. **æ— æƒå›¾æœ€çŸ­è·¯å¾„ = BFS**
æ¯èµ°ä¸€æ­¥çš„ä»£ä»·ä¸€æ ·ï¼ˆ1 æ­¥ï¼‰ï¼Œè¦æ‰¾æœ€çŸ­æ­¥æ•°ï¼Œè‡ªç„¶ç”¨ BFS æŒ‰â€œå±‚â€æ‰©æ•£ã€‚

2. **ä»å…¥å£å¼€å§‹åš BFS**
 - é˜Ÿåˆ—é‡Œå­˜ `(è¡Œ, åˆ—, å½“å‰æ­¥æ•°)`
 - æ¯æ¬¡å¼¹å‡ºä¸€ä¸ªä½ç½®ï¼Œæ‰©å±•å®ƒçš„ 4 ä¸ªç›¸é‚»æ ¼å­
 - ç¬¬ä¸€æ¬¡é‡åˆ°çš„â€œåœ¨è¾¹ç•Œä¸Šçš„ç©ºæ ¼â€å°±æ˜¯æœ€è¿‘å‡ºå£ï¼ˆå› ä¸º BFS å±‚åºä¿è¯â€œå…ˆåˆ°å…ˆçŸ­â€ï¼‰

3. **é¿å…é‡å¤è®¿é—®**
 - è®¿é—®è¿‡çš„æ ¼å­ä¸è¦å†è®¿é—®ï¼Œé¿å…æ­»å¾ªç¯å’Œé‡å¤è®¡ç®—
 - å¸¸ç”¨æŠ€å·§ï¼š**ç›´æ¥æŠŠè®¿é—®è¿‡çš„ `'.'` æ”¹æˆ `'+'`**ï¼Œç›¸å½“äºæ ‡è®°ä¸ºå¢™

4. **ç»†èŠ‚æ³¨æ„ï¼šå…¥å£ä¸æ˜¯å‡ºå£**
 - å…¥å£å¯èƒ½æœ¬èº«åœ¨è¾¹ç•Œï¼Œä½†é¢˜ç›®è¯´**ä¸èƒ½æŠŠå…¥å£å½“å‡ºå£**
 - æˆ‘ä»¬ä»å…¥å£å¼€å§‹ BFSï¼Œåªåœ¨æ‰©å±•åˆ°é‚»å±…æ—¶åˆ¤æ–­å®ƒæ˜¯ä¸æ˜¯è¾¹ç•Œå‡ºå£ï¼Œè¿™æ ·å¤©ç„¶æ’é™¤å…¥å£

5. **æ­¥æ•°å¦‚ä½•è®¡ç®—**
 - èµ·ç‚¹æ­¥æ•°è®¾ä¸º 0
 - æ¯èµ°åˆ°ä¸€ä¸ªé‚»å±…æ ¼å­ï¼Œæ­¥æ•°å°±æ˜¯ `å½“å‰æ­¥æ•° + 1`
 - ä¸€æ—¦ç¢°åˆ°è¾¹ç•Œå‡ºå£ï¼Œå°±è¿”å›è¿™ä¸ªæ­¥æ•°


---

## ä¸‰ã€ä»£ç å®ç°ï¼ˆPythonï¼Œå¸¦ä¸­æ–‡æ³¨é‡Šï¼ŒGoogle é£æ ¼ï¼‰

```python
from collections import deque
from typing import List


class Solution:
    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
        """è¿”å›ä»å…¥å£åˆ°æœ€è¿‘å‡ºå£çš„æœ€çŸ­æ­¥æ•°ï¼Œæ²¡æœ‰å‡ºå£åˆ™è¿”å› -1ã€‚

        ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰åœ¨ç½‘æ ¼ä¸­å¯»æ‰¾æœ€è¿‘çš„è¾¹ç•Œå‡ºå£ã€‚

        Args:
            maze: è¿·å®«ç½‘æ ¼ï¼Œ'+' è¡¨ç¤ºå¢™ï¼Œ'.' è¡¨ç¤ºç©ºåœ°ã€‚
            entrance: å…¥å£åæ ‡ [row, col]ï¼Œä¿è¯åœ¨ç©ºåœ°ä¸Šã€‚

        Returns:
            int: æœ€è¿‘å‡ºå£çš„æ­¥æ•°ï¼Œå¦‚æœä¸å­˜åœ¨å‡ºå£åˆ™è¿”å› -1ã€‚
        """
        rows = len(maze)
        cols = len(maze[0])
        start_r, start_c = entrance

        # å››ä¸ªæ–¹å‘ï¼šä¸Šã€ä¸‹ã€å·¦ã€å³
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        # é˜Ÿåˆ—ä¸­å…ƒç´ ä¸º (è¡Œ, åˆ—, å½“å‰æ­¥æ•°)
        queue = deque()
        queue.append((start_r, start_c, 0))

        # å°†å…¥å£æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œé¿å…å†å›åˆ°å…¥å£
        maze[start_r][start_c] = '+'

        while queue:
            r, c, dist = queue.popleft()

            for dr, dc in directions:
                nr = r + dr
                nc = c + dc

                # è¶Šç•Œåˆ™è·³è¿‡
                if nr < 0 or nr >= rows or nc < 0 or nc >= cols:
                    continue

                # åªèƒ½èµ°åˆ°ç©ºåœ°
                if maze[nr][nc] != '.':
                    continue

                # å¦‚æœè¿™ä¸ªç©ºåœ°åœ¨è¾¹ç•Œä¸Šï¼Œå°±æ˜¯ä¸€ä¸ªå‡ºå£
                # æ³¨æ„è¿™é‡Œä¸ä¼šæ˜¯å…¥å£ï¼Œå› ä¸ºå…¥å£å·²ç»è¢«æ ‡è®°ä¸º '+'
                if nr == 0 or nr == rows - 1 or nc == 0 or nc == cols - 1:
                    return dist + 1

                # æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œå…¥é˜Ÿ
                maze[nr][nc] = '+'
                queue.append((nr, nc, dist + 1))

        # æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å‡ºå£
        return -1
```

---

## å››ã€æ—¶é—´ / ç©ºé—´å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦ï¼š**O(m Ã— n)**
æ¯ä¸ªæ ¼å­æœ€å¤šå…¥é˜Ÿå‡ºé˜Ÿä¸€æ¬¡
- ç©ºé—´å¤æ‚åº¦ï¼š**O(m Ã— n)**
é˜Ÿåˆ—å’Œç½‘æ ¼æ ‡è®°çš„å¼€é”€ï¼ˆç½‘æ ¼æœ¬èº«å·²ç»™å‡ºï¼Œåªæ˜¯å°±åœ°ä¿®æ”¹ï¼‰


---

## äº”ã€é¢è¯•æ—¶ 30 ç§’å£è¿°æ€è·¯æ¨¡æ¿

ä½ å¯ä»¥ç›´æ¥èƒŒä¸‹é¢è¿™æ®µè¯ï¼ˆ30 ç§’å·¦å³ï¼‰ï¼š

> è¿™é¢˜æœ¬è´¨æ˜¯æ— æƒç½‘æ ¼çš„æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ç”¨ BFSã€‚ä»å…¥å£å¼€å§‹ï¼ŒæŠŠå®ƒæ”¾å…¥é˜Ÿåˆ—ï¼Œç„¶åæŒ‰å±‚æ‰©å±•å››ä¸ªæ–¹å‘çš„ç›¸é‚»æ ¼å­ã€‚æ¯æ¬¡åªèµ°åˆ°æ˜¯ '.' çš„ç©ºåœ°ï¼Œå¹¶ä¸”ç”¨åŸæ•°ç»„å°±åœ°æ ‡è®°æˆ '+' æ¥é˜²æ­¢é‡å¤è®¿é—®ã€‚å¯¹äºæ¯ä¸ªæ–°åˆ°è¾¾çš„ç©ºåœ°ï¼Œå¦‚æœå®ƒåœ¨è¾¹ç•Œä¸Šï¼Œå°±è¯´æ˜æ‰¾åˆ°äº†ä¸€ä¸ªå‡ºå£ï¼Œå› ä¸º BFS æ˜¯æŒ‰æ­¥æ•°ä»å°åˆ°å¤§æ‰©å±•çš„ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡é‡åˆ°çš„å‡ºå£å°±æ˜¯æœ€è¿‘çš„ï¼Œç›´æ¥è¿”å›å½“å‰æ­¥æ•°åŠ ä¸€ã€‚å¦‚æœ BFS å®Œæˆéƒ½æ²¡æœ‰é‡åˆ°è¾¹ç•Œç©ºåœ°ï¼Œå°±è¿”å› -1ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(mn)ã€‚

---
## ğŸ¤– Assistant

å¥½çš„ï¼Œæ²¡é—®é¢˜ï¼ä½œä¸ºä½ çš„é¢è¯•å‡†å¤‡ä¼™ä¼´ï¼Œæˆ‘éå¸¸ç†è§£ä½ çš„éœ€æ±‚ï¼šæ—¶é—´ç´§ã€ä»»åŠ¡é‡ï¼Œç›®æ ‡æ˜ç¡®â€”â€”å¿«é€ŸæŒæ¡é¢è¯•æ ¸å¿ƒé¢˜å‹ï¼Œè¾¾åˆ°èƒ½è¿‡å…³çš„æ°´å¹³ã€‚

é’ˆå¯¹åŠ›æ‰£ 1926. ã€Œè¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£ã€è¿™é“é¢˜ï¼Œæˆ‘ä»¬ç›´æ¥åˆ‡å…¥æœ¬è´¨ã€‚

---

### 1. é—®é¢˜åˆ†æä¸æœ¬è´¨å‰–æ

**é¢˜ç›®å¤§æ„ï¼š**
ç»™ä½ ä¸€ä¸ª `m x n` çš„è¿·å®«ï¼Œ`.` ä»£è¡¨è·¯ï¼Œ`+` ä»£è¡¨å¢™ã€‚ç»™ä½ ä¸€ä¸ªå…¥å£åæ ‡ `entrance`ã€‚ä½ éœ€è¦æ‰¾åˆ°ä»è¿™ä¸ªå…¥å£èµ°åˆ°ä»»ä½•ä¸€ä¸ª**å‡ºå£**ï¼ˆè¾¹ç•Œä¸Šçš„`.`ï¼‰çš„**æœ€çŸ­è·¯å¾„**ã€‚å¦‚æœèµ°ä¸åˆ°ï¼Œè¿”å› -1ã€‚

**æŠ“ä½å…³é”®è¯ï¼š**
* **è¿·å®«/ç½‘æ ¼å›¾ï¼š** è¿™ç±»é—®é¢˜éƒ½å¯ä»¥æŠ½è±¡æˆå›¾è®ºé—®é¢˜ã€‚æ¯ä¸ª `.` å•å…ƒæ ¼æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›¸é‚»çš„ `.` å•å…ƒæ ¼ä¹‹é—´æœ‰ä¸€æ¡è¾¹ã€‚
* **æœ€çŸ­è·¯å¾„ï¼š** è¿™æ˜¯æœ¬é¢˜çš„çµé­‚ï¼ä¸€çœ‹åˆ°**ç½‘æ ¼å›¾**é‡Œçš„**æœ€çŸ­è·¯å¾„**ï¼Œä½ çš„å¤§è„‘é‡Œåº”è¯¥ç«‹åˆ»é—ªç°å‡ºä¸€ä¸ªç®—æ³•ï¼š**å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFS, Breadth-First Searchï¼‰**ã€‚

### 2. æ ¸å¿ƒæ€è·¯ä¸ç®—æ³•é€‰æ‹© (ä¸ºä»€ä¹ˆæ˜¯BFSï¼Ÿ)

* **ä¸ºä»€ä¹ˆæ˜¯ BFSï¼Œè€Œä¸æ˜¯ DFS (æ·±åº¦ä¼˜å…ˆæœç´¢)ï¼Ÿ**
 * æƒ³è±¡ä¸€ä¸‹æ°´æ³¢çº¹ã€‚BFS å°±åƒå¾€æ°´é‡Œæ‰”ä¸€å—çŸ³å¤´ï¼Œæ³¢çº¹ä¼šä¸€åœˆä¸€åœˆï¼ˆä¸€å±‚ä¸€å±‚ï¼‰åœ°å‘å¤–æ‰©æ•£ã€‚ç¬¬ä¸€åœˆæ˜¯ç¦»çŸ³å¤´è·ç¦»ä¸º1çš„æ‰€æœ‰ç‚¹ï¼Œç¬¬äºŒåœˆæ˜¯è·ç¦»ä¸º2çš„æ‰€æœ‰ç‚¹...
 * è¿™å’Œæˆ‘ä»¬æ‰¾æœ€çŸ­è·¯å¾„çš„éœ€æ±‚å®Œç¾å¥‘åˆï¼ä»å…¥å£ï¼ˆçŸ³å¤´ï¼‰å¼€å§‹ï¼ŒBFS ä¼šå…ˆæ¢ç´¢å®Œæ‰€æœ‰è·ç¦»ä¸º 1 çš„ç‚¹ï¼Œå†æ¢ç´¢å®Œæ‰€æœ‰è·ç¦»ä¸º 2 çš„ç‚¹... æ‰€ä»¥ï¼Œ**BFS ä¿è¯äº†æˆ‘ä»¬ç¬¬ä¸€æ¬¡æ‰¾åˆ°å‡ºå£æ—¶ï¼Œè¿™æ¡è·¯å¾„ä¸€å®šæ˜¯æœ€çŸ­çš„**ã€‚
 * è€Œ DFS æ˜¯ä¸€æ¡è·¯èµ°åˆ°é»‘ï¼Œä¸æ’å—å¢™ä¸å›å¤´ã€‚å®ƒèƒ½æ‰¾åˆ°ä¸€ä¸ªå‡ºå£ï¼Œä½†ä¸èƒ½ä¿è¯è¿™ä¸ªå‡ºå£æ˜¯æœ€è¿‘çš„ã€‚

* **æ€»ç»“ï¼š** åœ¨æ‰€æœ‰è¾¹çš„æƒé‡éƒ½ç›¸ç­‰ï¼ˆæ¯”å¦‚è¿™é‡Œï¼Œæ¯æ¬¡ç§»åŠ¨éƒ½ç®— 1 æ­¥ï¼‰çš„å›¾ä¸­ï¼Œæ±‚æœ€çŸ­è·¯å¾„ï¼Œ**BFS æ˜¯æ ‡å‡†ç­”æ¡ˆ**ã€‚

### 3. è§£é¢˜æ­¥éª¤æ‹†è§£

ä½¿ç”¨ BFS è§£è¿™é“é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä¸‰ä¸ªæ ¸å¿ƒå·¥å…·ï¼š
1. **ä¸€ä¸ªé˜Ÿåˆ— (Queue):** ç”¨æ¥å­˜æ”¾æ¥ä¸‹æ¥è¦å»æ¢ç´¢çš„èŠ‚ç‚¹ã€‚å°±åƒæ˜¯ BFS çš„â€œå¾…åŠäº‹é¡¹åˆ—è¡¨â€ã€‚
2. **ä¸€ä¸ªè®°å½•å·²è®¿é—®ä½ç½®çš„é›†åˆ (Visited Set):** é˜²æ­¢åœ¨è¿·å®«é‡Œæ¥å›ç»•åœˆï¼Œé™·å…¥æ­»å¾ªç¯ã€‚
3. **ä¸€ä¸ªè®°å½•æ­¥æ•°çš„æ–¹æ³•:** æˆ‘ä»¬å¯ä»¥åœ¨é˜Ÿåˆ—é‡Œå­˜æ”¾ `(è¡Œ, åˆ—, æ­¥æ•°)` è¿™æ ·çš„å…ƒç»„ï¼Œè½»æ¾è¿½è¸ªæ­¥æ•°ã€‚

**å…·ä½“æ­¥éª¤ï¼š**

1. **åˆå§‹åŒ–ï¼š**
 * åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ— `q`ã€‚
 * å°†å…¥å£åæ ‡ `entrance` å’Œåˆå§‹æ­¥æ•° `0` ä½œä¸ºä¸€ä¸ªå…ƒç»„ `(å…¥å£è¡Œ, å…¥å£åˆ—, 0)` æ”¾å…¥é˜Ÿåˆ—ã€‚
 * åˆ›å»ºä¸€ä¸ª `visited` é›†åˆï¼Œå¹¶å°†å…¥å£åæ ‡æ”¾è¿›å»ï¼Œè¡¨ç¤ºå·²ç»è®¿é—®è¿‡ã€‚

2. **å¾ªç¯æœç´¢ï¼š**
 * å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶ï¼Œä»é˜Ÿåˆ—å¤´éƒ¨å–å‡ºä¸€ä¸ªå…ƒç´  `(å½“å‰è¡Œ, å½“å‰åˆ—, å½“å‰æ­¥æ•°)`ã€‚
 * **åˆ¤æ–­æ˜¯å¦ä¸ºå‡ºå£ï¼š**
 * æ£€æŸ¥å½“å‰ä½ç½® `(å½“å‰è¡Œ, å½“å‰åˆ—)` æ˜¯ä¸æ˜¯åœ¨è¿·å®«çš„è¾¹ç•Œä¸Šã€‚
 * **ç‰¹åˆ«æ³¨æ„ï¼š** é¢˜ç›®è¦æ±‚å…¥å£æœ¬èº«ä¸èƒ½ç®—ä½œå‡ºå£ã€‚æ‰€ä»¥ï¼Œå¦‚æœå½“å‰ä½ç½®æ˜¯å…¥å£ï¼Œç›´æ¥è·³è¿‡ï¼Œç»§ç»­æœç´¢ã€‚
 * å¦‚æœå½“å‰ä½ç½®åœ¨è¾¹ç•Œä¸Šï¼Œå¹¶ä¸”ä¸æ˜¯å…¥å£ï¼Œé‚£ä¹ˆæ­å–œä½ ï¼Œå·²ç»æ‰¾åˆ°äº†æœ€è¿‘çš„å‡ºå£ï¼ç›´æ¥è¿”å› `å½“å‰æ­¥æ•°`ã€‚

3. **æ¢ç´¢é‚»å±…ï¼š**
 * å¦‚æœå½“å‰ä½ç½®ä¸æ˜¯å‡ºå£ï¼Œå°±è€ƒå¯Ÿå®ƒçš„ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªç›¸é‚»çš„æ ¼å­ã€‚
 * å¯¹äºæ¯ä¸€ä¸ªç›¸é‚»çš„æ ¼å­ï¼š
 * æ£€æŸ¥å®ƒæ˜¯å¦åœ¨è¿·å®«è¾¹ç•Œå†…ã€‚
 * æ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é€šè·¯ `.`ã€‚
 * æ£€æŸ¥å®ƒæ˜¯å¦**æ²¡æœ‰è¢«è®¿é—®è¿‡**ã€‚
 * å¦‚æœé‚»å±…æ»¡è¶³ä»¥ä¸Šæ‰€æœ‰æ¡ä»¶ï¼Œå°±æŠŠå®ƒåŠ å…¥ `visited` é›†åˆï¼Œç„¶åå°†å…¶åæ ‡å’Œ `å½“å‰æ­¥æ•° + 1` ä½œä¸ºä¸€ä¸ªæ–°å…ƒç»„æ”¾å…¥é˜Ÿåˆ— `q` çš„å°¾éƒ¨ã€‚

4. **å¤„ç†æ— è§£æƒ…å†µï¼š**
 * å¦‚æœé˜Ÿåˆ—éƒ½ç©ºäº†ï¼ˆæ‰€æœ‰èƒ½èµ°çš„è·¯éƒ½èµ°å®Œäº†ï¼‰ï¼Œè¿˜æ²¡æœ‰æ‰¾åˆ°å‡ºå£ï¼Œé‚£å°±è¯´æ˜å…¥å£è¢«å¢™å®Œå…¨å µæ­»äº†ï¼Œæ— æ³•åˆ°è¾¾ä»»ä½•å‡ºå£ã€‚æ­¤æ—¶ï¼Œè¿”å› `-1`ã€‚

---

### 4. Python ä»£ç å®ç° (æ³¨é‡Šæ¸…æ™°ï¼Œé£æ ¼è§„èŒƒ)

```python
import collections
from typing import List

def nearest_exit(maze: List[List[str]], entrance: List[int]) -> int:
    """
    ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS) å¯»æ‰¾ä»å…¥å£åˆ°æœ€è¿‘å‡ºå£çš„æœ€çŸ­è·¯å¾„ã€‚

    Args:
        maze: ä¸€ä¸ªäºŒç»´åˆ—è¡¨ï¼Œè¡¨ç¤ºè¿·å®«çš„å¸ƒå±€ã€‚
        entrance: ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªæ•´æ•°çš„åˆ—è¡¨ï¼Œè¡¨ç¤ºå…¥å£çš„åæ ‡ [row, col]ã€‚

    Returns:
        ä»å…¥å£åˆ°æœ€è¿‘å‡ºå£çš„æœ€çŸ­è·¯å¾„æ­¥æ•°ï¼Œå¦‚æœä¸å­˜åœ¨è·¯å¾„åˆ™è¿”å› -1ã€‚
    """
    # è·å–è¿·å®«çš„å°ºå¯¸
    rows, cols = len(maze), len(maze[0])
    
    # åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œå­˜æ”¾ (è¡Œ, åˆ—, æ­¥æ•°)
    # collections.deque æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„åŒç«¯é˜Ÿåˆ—ï¼Œéå¸¸é€‚åˆç”¨äºBFS
    queue = collections.deque([(entrance[0], entrance[1], 0)])
    
    # ä½¿ç”¨ä¸€ä¸ªé›†åˆæ¥è®°å½•è®¿é—®è¿‡çš„ä½ç½®ï¼Œé˜²æ­¢é‡å¤è®¿é—®å’Œæ­»å¾ªç¯
    # å°†å…¥å£ä½ç½®å…ˆæ ‡è®°ä¸ºå·²è®¿é—®ï¼Œä¹Ÿå¯ä»¥ç›´æ¥åœ¨mazeä¸­ä¿®æ”¹ï¼Œä½†é›†åˆæ›´æ¸…æ™°
    visited = {(entrance[0], entrance[1])}

    # å®šä¹‰å››ä¸ªæ–¹å‘çš„ç§»åŠ¨
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # å³, å·¦, ä¸‹, ä¸Š

    # BFS ä¸»å¾ªç¯
    while queue:
        # ä»é˜Ÿåˆ—å·¦ä¾§å¼¹å‡ºä¸€ä¸ªèŠ‚ç‚¹
        current_row, current_col, steps = queue.popleft()

        # æ£€æŸ¥æ˜¯å¦ä¸ºå‡ºå£ (æ˜¯è¾¹ç•Œç‚¹ä¸”ä¸æ˜¯å…¥å£ç‚¹)
        is_at_border = (current_row == 0 or current_row == rows - 1 or
                        current_col == 0 or current_col == cols - 1)
        
        # åªæœ‰åœ¨æ­¥æ•° > 0 çš„æƒ…å†µä¸‹æ‰å¯èƒ½æ˜¯å‡ºå£ï¼Œè¿™å·§å¦™åœ°æ’é™¤äº†å…¥å£æœ¬èº«å°±æ˜¯å‡ºå£çš„æƒ…å†µ
        if is_at_border and steps > 0:
            return steps

        # æ¢ç´¢å››ä¸ªæ–¹å‘çš„é‚»å±…
        for dr, dc in directions:
            next_row, next_col = current_row + dr, current_col + dc

            # æ£€æŸ¥é‚»å±…æ˜¯å¦åˆæ³•
            # 1. åœ¨è¾¹ç•Œå†…
            if 0 <= next_row < rows and 0 <= next_col < cols:
                # 2. æ˜¯é€šè·¯ ('.')
                # 3. æœªè¢«è®¿é—®è¿‡
                if maze[next_row][next_col] == '.' and (next_row, next_col) not in visited:
                    # æ ‡è®°ä¸ºå·²è®¿é—®
                    visited.add((next_row, next_col))
                    # åŠ å…¥é˜Ÿåˆ—ï¼Œæ­¥æ•°åŠ ä¸€
                    queue.append((next_row, next_col, steps + 1))
    
    # å¦‚æœé˜Ÿåˆ—ä¸ºç©ºè¿˜æ²¡æ‰¾åˆ°å‡ºå£ï¼Œè¯´æ˜æ— è·¯å¯èµ°
    return -1

```

**ä»£ç é€»è¾‘ä¼˜åŒ–è¯´æ˜ï¼š**
ä»£ç ä¸­ `if is_at_border and steps > 0:` è¿™ä¸ªåˆ¤æ–­éå¸¸ç®€æ´ã€‚å› ä¸ºå…¥å£çš„ `steps` æ˜¯ `0`ï¼Œæ‰€ä»¥è¿™ä¸ªæ¡ä»¶å¤©ç„¶åœ°æ’é™¤äº†â€œå…¥å£å°±æ˜¯å‡ºå£â€çš„æƒ…å†µï¼Œæ¯” `(current_row, current_col) != (entrance[^0], entrance[^1])` æ›´ä¼˜é›…ã€‚

---

### 5. é¢è¯•å£è¿°æ€è·¯è¦ç‚¹ (30ç§’å†…è®²å®Œ)

> é¢è¯•å®˜ä½ å¥½ï¼Œå¯¹äºè¿™é“é¢˜ï¼Œæˆ‘çš„æ€è·¯æ˜¯è¿™æ ·çš„ï¼š
>
> 1. **å®šæ€§é—®é¢˜ï¼š** è¿™æœ¬è´¨ä¸Šæ˜¯åœ¨ä¸€ä¸ªç½‘æ ¼å›¾ä¸­ï¼Œå¯»æ‰¾ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„**æœ€çŸ­è·¯å¾„**é—®é¢˜ã€‚
> 2. **é€‰æ‹©ç®—æ³•ï¼š** å¯¹äºè¿™ç±»æ‰€æœ‰è·¯å¾„æƒé‡éƒ½ä¸º1çš„åœºæ™¯ï¼Œ**å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰**æ˜¯æœ€é«˜æ•ˆã€æœ€ç»å…¸çš„é€‰æ‹©ã€‚å› ä¸ºå®ƒèƒ½ä¿è¯ç¬¬ä¸€æ¬¡æ‰¾åˆ°çš„è·¯å¾„å°±æ˜¯æœ€çŸ­çš„ã€‚
> 3. **æ ¸å¿ƒå®ç°ï¼š** æˆ‘ä¼šä½¿ç”¨ä¸€ä¸ª**é˜Ÿåˆ—**æ¥è¾…åŠ©è¿›è¡ŒBFSã€‚é˜Ÿåˆ—é‡Œå­˜æ”¾ `(åæ ‡, æ­¥æ•°)`ã€‚åŒæ—¶ï¼Œç”¨ä¸€ä¸ª**`visited`é›†åˆ**æ¥è®°å½•èµ°è¿‡çš„ç‚¹ï¼Œé˜²æ­¢ç»•åœˆã€‚ä»å…¥å£å¼€å§‹ï¼Œé€å±‚å‘å¤–æ¢ç´¢ï¼Œç›´åˆ°ç¬¬ä¸€æ¬¡é‡åˆ°è¾¹ç•Œä¸Šçš„é€šè·¯ï¼Œè¿™ä¸ªç‚¹çš„æ­¥æ•°å°±æ˜¯ç­”æ¡ˆã€‚å¦‚æœé˜Ÿåˆ—ä¸ºç©ºè¿˜æ²¡æ‰¾åˆ°ï¼Œå°±è¯´æ˜æ²¡æœ‰å‡ºå£ã€‚

è¿™å¥—è¯´è¾æ¸…æ™°åœ°å±•ç°äº†ä½ å¯¹é—®é¢˜çš„ç†è§£ã€ç®—æ³•çš„é€‰æ‹©ä¾æ®å’Œå®ç°çš„å…³é”®ç‚¹ï¼Œç®€æ´æœ‰åŠ›ï¼Œè¶³ä»¥ä½“ç°ä½ çš„é€»è¾‘èƒ½åŠ›ã€‚ç¥ä½ é¢è¯•é¡ºåˆ©ï¼

---
## ğŸ§‘â€ğŸ’» User

ä¸‹é¢æˆ‘çš„ä»£ç å“ªé‡Œå‡ºäº†é—®é¢˜ï¼Ÿ
class Solution:
 def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
 rows, cols = len(maze), len(maze[^0])
 start_r, start_c = entrance
 maze[start_r][start_c] = '+'
 dq = collections.deque([(start_r, start_c, 0)])
 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
 while dq:
 curr_r, curr_c, steps = dq.popleft()
 if curr_r in [0, rows - 1] or curr_c in [0, cols - 1]:
 return steps
 for dr, dc in directions:
 nr, nc = curr_r + dr, curr_c + dc
 if not (0 <= nr < rows) or not (0 <= nc < cols):
 continue
 if maze[nr][nc] != '.':
 continue
 dq.append((nr, nc, steps + 1))
 maze[nr][nc] = '+'
 return -1

---
## ğŸ¤– Assistant

é—®é¢˜å‡ºåœ¨ã€ŒæŠŠå…¥å£å½“æˆäº†å‡ºå£ã€ã€‚

ä½ ç°åœ¨åœ¨æ¯æ¬¡ `popleft()` æ—¶è¿™æ ·åˆ¤æ–­å‡ºå£ï¼š

```python
curr_r, curr_c, steps = dq.popleft()
if curr_r in [0, rows - 1] or curr_c in [0, cols - 1]:
    return steps
```

è¿™ä¼šæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š

1. **å…¥å£åœ¨è¾¹ç•Œæ—¶è¢«è¯¯åˆ¤ä¸ºå‡ºå£**
é¢˜ç›®è¦æ±‚ï¼šå‡ºå£æ˜¯**è¾¹ç•Œä¸Šçš„ `'.'`ï¼Œä½†ä¸èƒ½æ˜¯å…¥å£æœ¬èº«**ã€‚
ä½ çš„ä»£ç ä¸€å¼€å§‹å°±æŠŠå…¥å£ä¸¢è¿›é˜Ÿåˆ—ï¼Œç¬¬ä¸€æ­¥å°±ä¼šåˆ¤æ–­åæ ‡æ˜¯å¦åœ¨è¾¹ç•Œï¼Œå¦‚æœå…¥å£æœ¬èº«åœ¨è¾¹ç•Œï¼Œç›´æ¥ `return 0`ï¼Œè¿™æ˜¯é”™è¯¯çš„ã€‚

åä¾‹ï¼ˆåŠ›æ‰£ä¼šæœ‰ç±»ä¼¼ç”¨ä¾‹ï¼‰ï¼š
```python
   maze = [[".", "+"]]
   entrance = [0, 0]
   ```
   æ­£ç¡®ç­”æ¡ˆï¼š`-1`ï¼ˆå”¯ä¸€çš„ '.' å°±æ˜¯å…¥å£ï¼Œæ²¡æœ‰å…¶ä»–å‡ºå£ï¼‰  
   ä½ çš„ä»£ç ï¼š  
   - é˜Ÿåˆ—åˆå§‹ä¸º `[(0, 0, 0)]`
   - å¼¹å‡º `(0, 0, 0)`ï¼Œ`curr_r == 0` åœ¨è¾¹ç•Œï¼Œé©¬ä¸Š `return 0` â€”â€” é”™äº†ã€‚

2. ä½ è™½ç„¶æŠŠå…¥å£æ ‡è®°æˆ `'+'`ï¼š
   ```python
   maze[start_r][start_c] = '+'
   ```
   ä½†åˆ¤æ–­å‡ºå£çš„æ—¶å€™æ ¹æœ¬æ²¡çœ‹ `maze[curr_r][curr_c]` æ˜¯ä»€ä¹ˆï¼Œåªçœ‹åæ ‡æ˜¯ä¸æ˜¯è¾¹ç•Œï¼Œæ‰€ä»¥å…¥å£ä»ç„¶å¯èƒ½è¢«å½“ä½œå‡ºå£ã€‚


---

## æœ€å°ä¿®æ”¹ç‰ˆï¼šä¿æŒä½ ç°åœ¨å†™æ³•ï¼Œåªä¿®æ­£é€»è¾‘

åœ¨åˆ¤æ–­å‡ºå£æ—¶ï¼Œ**æ’é™¤å…¥å£åæ ‡**ï¼š

```python
import collections
from typing import List


class Solution:
 def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
 rows, cols = len(maze), len(maze[^0])
 start_r, start_c = entrance
 maze[start_r][start_c] = '+'
 dq = collections.deque([(start_r, start_c, 0)])
 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

 while dq:
 curr_r, curr_c, steps = dq.popleft()

 # ä¸æ˜¯å…¥å£æœ¬èº«ï¼Œä¸”åœ¨è¾¹ç•Œï¼Œæ‰æ˜¯å‡ºå£
 if ((curr_r != start_r or curr_c != start_c) and
 (curr_r in (0, rows - 1) or curr_c in (0, cols - 1))):
 return steps

 for dr, dc in directions:
 nr, nc = curr_r + dr, curr_c + dc
 if not (0 <= nr < rows and 0 <= nc < cols):
 continue
 if maze[nr][nc] != '.':
 continue
 dq.append((nr, nc, steps + 1))
 maze[nr][nc] = '+'

 return -1
```

---

## æ›´æ¨èçš„å†™æ³•ï¼ˆé€»è¾‘æ›´æ¸…æ™°ï¼‰

æŠŠâ€œæ˜¯ä¸æ˜¯å‡ºå£â€çš„åˆ¤æ–­æ”¾åœ¨**æ‰©å±•é‚»å±…æ—¶**ï¼Œè¿™æ ·å¤©ç„¶ä¸ä¼šæŠŠå…¥å£ç®—è¿›å»ï¼ˆå› ä¸ºå…¥å£æ²¡ä½œä¸ºé‚»å±…å…¥é˜Ÿï¼‰ï¼š

```python
import collections
from typing import List


class Solution:
 def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
 """BFS å¯»æ‰¾æœ€è¿‘å‡ºå£ï¼Œå‡ºå£ä¸èƒ½æ˜¯å…¥å£æœ¬èº«ã€‚"""
 rows, cols = len(maze), len(maze[^0])
 start_r, start_c = entrance

 maze[start_r][start_c] = '+' # æ ‡è®°å…¥å£å·²è®¿é—®
 dq = collections.deque([(start_r, start_c, 0)])
 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

 while dq:
 curr_r, curr_c, steps = dq.popleft()

 for dr, dc in directions:
 nr, nc = curr_r + dr, curr_c + dc

 # è¶Šç•Œ
 if not (0 <= nr < rows and 0 <= nc < cols):
 continue
 # ä¸æ˜¯ç©ºåœ°ä¸èƒ½èµ°
 if maze[nr][nc] != '.':
 continue

 # è¿™ä¸ªç©ºåœ°åœ¨è¾¹ç•Œä¸Šï¼Œå³ä¸ºå‡ºå£
 if nr == 0 or nr == rows - 1 or nc == 0 or nc == cols - 1:
 return steps + 1

 # å¦åˆ™æ˜¯å†…éƒ¨ç©ºåœ°ï¼Œå…¥é˜Ÿå¹¶æ ‡è®°è®¿é—®
 maze[nr][nc] = '+'
 dq.append((nr, nc, steps + 1))

 return -1
```

---

## é¢è¯•å£è¿°è¦ç‚¹ï¼ˆ30 ç§’ï¼‰

> æˆ‘ç”¨ BFS æ±‚æ— æƒç½‘æ ¼ä¸Šçš„æœ€çŸ­è·¯å¾„ã€‚ä»å…¥å£å¼€å§‹åšå±‚åºéå†ï¼Œæ¯æ¬¡å‘å››ä¸ªæ–¹å‘æ‰©å±•ï¼Œåªèµ°åˆ°æ˜¯ '.' çš„ç©ºåœ°ï¼Œå¹¶ä¸”ç”¨åŸæ•°ç»„æŠŠè®¿é—®è¿‡çš„ä½ç½®æ”¹æˆ '+'ï¼Œé˜²æ­¢é‡å¤è®¿é—®ã€‚åˆ¤æ–­å‡ºå£æ—¶è¦æ³¨æ„ä¸èƒ½æŠŠå…¥å£æœ¬èº«ç®—è¿›å»ï¼šæˆ‘åªåœ¨è®¿é—®åˆ°æ–°çš„ç©ºåœ°æ—¶ï¼Œå¦‚æœå®ƒåœ¨è¾¹ç•Œä¸Šï¼Œå°±ç«‹å³è¿”å›å½“å‰æ­¥æ•°åŠ ä¸€ï¼Œå› ä¸º BFS æŒ‰å±‚æ‰©å±•ï¼Œç¬¬ä¸€æ¬¡é‡åˆ°çš„å‡ºå£å°±æ˜¯æœ€è¿‘å‡ºå£ã€‚å¦‚æœ BFS ç»“æŸéƒ½æ²¡é‡åˆ°å‡ºå£ï¼Œå°±è¿”å› -1ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ O(mn)ã€‚
