# 力扣完全二叉树检验讲解

## 🧑‍💻 User

讲解力扣958. 二叉树的完全性检验

---
## 🤖 Assistant

**题目：LeetCode 958. 二叉树的完全性检验**

---

## 1. 题意 + 完全二叉树定义

题目：给你一棵二叉树的根节点 `root`，判断这棵树是不是**完全二叉树**。

**完全二叉树定义：**

- 除了**最后一层**外，其他每一层都是**满的**（左右孩子都有）。
- 最后一层的节点都**尽可能向左对齐**，不能中间出现“空洞”。

举个反例结构（不是完全二叉树）：

```
    1
   / \
  2   3
   \
    4
```

第三层中，`2` 节点左孩子为空、右孩子不空，中间有“空洞”，不符合完全二叉树。

---

## 2. 核心思路（推荐、面试可直接用）：层序遍历 + 空节点后不能再出现非空

**一句话：**
做一遍层序遍历（BFS），一旦在遍历过程中遇到 `None`（空孩子），就记个标记；如果之后又遇到非空节点，说明中间有缺口，不是完全二叉树。

### 步骤

1. 用队列做层序遍历，从根节点开始入队。
2. 维护一个标记 `seen_null = False`：
 - 每次从队列弹出一个节点 `node`：
 - 如果 `node` 为 `None`：
 把 `seen_null` 设为 `True`，继续处理队列。
 - 如果 `node` 不为空：
 - 如果 `seen_null == True`，说明之前某一层已经出现过空节点，现在又出现非空节点 ⇒ 中间有“洞” ⇒ 直接返回 `False`。
 - 否则，把 `node.left` 和 `node.right` 都入队（可以是 `None`）。
3. 遍历结束都没违例 ⇒ 返回 `True`。

### 为什么这个方法对？

**完全二叉树的关键性质**：
如果按层从左到右遍历节点（包括空指针位置），那么：

- 一旦出现了第一个 `None` 位置（某个孩子为空），
- 之后出现的任何位置都必须是 `None`，
- 不能再出现非空节点，否则说明中间有空洞（“左有空，右有实”）。

我们的遍历就是严格按这一性质在检查。

### 时间 / 空间复杂度

- 时间复杂度：`O(n)`，每个节点最多入队出队一次。
- 空间复杂度：`O(n)`，队列在最宽层时最多放 `O(n)` 个节点（包括 None）。

---

## 3. 面试 30 秒口述版（你可以背下来的）

> 用层序遍历来判断完全二叉树。我用一个队列，从根节点开始往外一层层遍历。遍历的时候允许遇到空节点，一旦遇到空节点我打一个标记，从这之后按照完全二叉树的性质，就不应该再出现任何非空节点了：如果在标记之后还看到了非空节点，就说明树的中间存在“空洞”，即不是完全二叉树，直接返回 False。如果遍历完都没违反这个条件，就返回 True。时间复杂度 O(n)，空间 O(n)。

---

## 4. Python 代码（BFS + seen_null）

```python
# Definition for a binary tree node.
# LeetCode 会预先定义这个类，这里只是方便本地调试时使用。
class TreeNode:
    """二叉树节点定义。"""

    def __init__(self, val=0, left=None, right=None):
        """初始化二叉树节点.

        Args:
            val: 节点的值.
            left: 左子节点.
            right: 右子节点.
        """
        self.val = val
        self.left = left
        self.right = right


from collections import deque


class Solution:
    """完全二叉树检验问题的解法."""

    def isCompleteTree(self, root: TreeNode) -> bool:
        """判断一棵二叉树是否为完全二叉树.

        思路：
        层序遍历（BFS），在遍历过程中允许遇到空节点。
        一旦遇到第一个空节点，之后如果再遇到任何非空节点，
        说明中间出现了“空洞”，不符合完全二叉树定义。

        Args:
            root: 二叉树根节点.

        Returns:
            若为完全二叉树返回 True，否则返回 False.
        """
        if not root:
            # 空树通常视为完全二叉树
            return True

        queue = deque([root])
        seen_null = False  # 是否已经遇到过空节点

        while queue:
            node = queue.popleft()

            if node is None:
                # 一旦遇到空节点，标记后续不能再有非空节点
                seen_null = True
            else:
                # 如果之前已经见过空节点，现在又见到非空节点 ⇒ 不是完全二叉树
                if seen_null:
                    return False
                # 即使孩子为空也照样入队，这样才能精确捕捉到空洞位置
                queue.append(node.left)
                queue.append(node.right)

        # 遍历结束未发现违例，说明是完全二叉树
        return True
```

---

## 5. 可选补充思路（面试中能加一句加分）：索引法

可以顺带提一句「还有一种等价写法」：

- 对每个节点按完全二叉树的数组表示方式编一个索引：
 - 根节点 index = 1
 - 左孩子 = `2 * i`
 - 右孩子 = `2 * i + 1`
- BFS 遍历同时记录：节点总数 `count`、最大索引 `max_index`。
- 完全二叉树的性质：如果是完全二叉树，那么最后一个节点的索引应该刚好等于节点数：`max_index == count`。
- 否则就说明某些位置没节点、后面却有节点 ⇒ 不是完全二叉树。

代码略；你在面试时可以只提一下这个思路，显示你知道另一种「索引判定法」。

---

如果你愿意，下一题可以继续选一两道二叉树经典题（如：对称二叉树、二叉树层序遍历、二叉树的右视图），一起把二叉树题型串起来。

---
## 🧑‍💻 User

索引法的复杂度会更低吗

---
## 🤖 Assistant

不会，本质上两种方法**时间复杂度和空间复杂度是一个级别的**。

---

## 1. 时间复杂度对比

两种方法都要「至少看一眼」每个节点：

- **方法一：BFS + seen_null**
 - 层序遍历整棵树，每个节点最多入队、出队一次
 - 时间复杂度：**O(n)**

- **方法二：索引法**
 - 无论你用 BFS 还是 DFS，都要访问每个节点一次，给它分配索引
 - 同样是：**O(n)**

所以从大 O 角度，两者**时间复杂度完全一样**，都必须遍历全树。

---

## 2. 空间复杂度对比

- **BFS + seen_null**
 - 需要一个队列，最坏情况下（倒数第二层接近满）队列大小是 O(n)
 - 空间复杂度：**O(n)**

- **索引法**
 - 如果用 BFS：同样需要一个队列，也是 **O(n)**
 - 如果用 DFS：只用递归栈或显式栈，最坏深度 O(h)，不平衡树时 h 可能接近 n
 - 所以严格讲也是 **O(n)**，只是常数略有差异

在 LeetCode 这道题的规模下（节点数不大），两种方法空间上**没有数量级差别**。

---

## 3. 面试怎么说更合适？

可以这样回答（简短版，可以背）：

> 索引法从时间复杂度上并不会更低，两个方法都需要遍历所有节点，都是 O(n)。空间上如果用 BFS，也都是 O(n)；索引法可以配合 DFS 把空间做到 O(h)，但整体量级还是一样的。实际实现里我更倾向于用层序遍历 + seen_null 的方法，可读性高，也不容易出错；索引法可以作为一个补充思路提一下。

面试时直接用 **BFS + seen_null** 就够了，索引法更多是展示你知道另一种等价判定方式。
