# 力扣奇偶树题目讲解

## 🧑‍💻 User

讲解力扣题目1609. 奇偶树

---
## 🤖 Assistant

题意 + 规则总结（1609. 奇偶树）
----------------------------------

给你一棵二叉树，问它是不是“奇偶树”：

- 按层编号：根节点是第 0 层，下面一层是第 1 层，以此类推。
- **偶数层（0, 2, 4, ...）：**
 - 这一层所有节点的值必须是 **奇数**。
 - 并且这些值从左到右 **严格递增**。
- **奇数层（1, 3, 5, ...）：**
 - 这一层所有节点的值必须是 **偶数**。
 - 并且这些值从左到右 **严格递减**。

只要有一层不满足，就返回 `False`，全部满足返回 `True`。

本质思路（核心就两点）
----------------------

1. 这个题的约束是在“每一层”上的，所以天然适合用 **层序遍历（BFS）**。
2. 对于每一层，我们需要同时检查两件事：
 - 值的奇偶性是否正确（看层号是奇数层还是偶数层）
 - 从左到右的单调性（偶数层严格递增，奇数层严格递减）

算法步骤（思路很直接）
----------------------

1. 用队列做 BFS，从根节点开始一层一层地遍历。
2. 维护一个变量 `level` 表示当前是第几层（0 开始）。
3. 每一层：
 - 先拿到这一层的节点个数 `size`。
 - 根据是奇数层还是偶数层，设置一个 `prev` 初始值：
 - 偶数层：需要 **严格递增**，所以 `prev` 设为负无穷，例如 `prev = float('-inf')`
 - 奇数层：需要 **严格递减**，所以 `prev` 设为正无穷，例如 `prev = float('inf')`
 - 然后从左到右遍历这一层的所有节点：
 - 检查当前值的奇偶性：
 - 偶数层：值必须是奇数 `val % 2 == 1`
 - 奇数层：值必须是偶数 `val % 2 == 0`
 - 检查单调性：
 - 偶数层：`val` 必须 `> prev`
 - 奇数层：`val` 必须 `< prev`
 - 如果任一条件不满足，立即返回 `False`
 - 否则更新 `prev = val`，并把左右子节点加入队列。
 - 这一层检查完，`level += 1`，继续下一层。
4. 所有层都检查通过，就返回 `True`。

时间与空间复杂度
-----------------

- 时间复杂度：`O(N)`，每个节点只访问一次。
- 空间复杂度：`O(N)`，队列在最宽的一层可能存放 `O(N)` 个节点。

面试可直接复述的 30 秒口述版
-----------------------------

> 这题约束都在“层”上，所以我用 BFS 做层序遍历。
> 用队列一层一层处理，维护一个 `level` 表示当前层数。对于每一层，我先根据层号决定要求：偶数层要求值是奇数并且严格递增，奇数层要求值是偶数并且严格递减。
> 我在每一层里维护一个 `prev`，偶数层初始设为负无穷、奇数层设为正无穷，遍历这一层的节点时检查当前值是否满足奇偶性，并且和 `prev` 比较是否满足严格单调，不满足就直接返回 False。全部层都通过检查就返回 True。时间复杂度 O(N)。

Python 代码（符合 Google Python Style，含中文注释）
--------------------------------------------------

```python
from collections import deque
from typing import Optional


# LeetCode 已定义的二叉树节点结构
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
        """判断一棵二叉树是否为奇偶树。

        奇偶树定义：
        - 偶数层（从 0 开始）：节点值为奇数，且从左到右严格递增。
        - 奇数层：节点值为偶数，且从左到右严格递减。

        Args:
            root: 二叉树根节点。

        Returns:
            如果是奇偶树返回 True，否则返回 False。
        """
        if not root:
            # 一般情况下 root 不会为空，但为空也算满足条件。
            return True

        queue = deque([root])
        level = 0  # 当前层编号，从 0 开始

        while queue:
            size = len(queue)
            # 根据当前层是偶数层还是奇数层设置 prev 初始值
            if level % 2 == 0:
                # 偶数层要求严格递增，所以初始设为负无穷
                prev_val = float("-inf")
            else:
                # 奇数层要求严格递减，所以初始设为正无穷
                prev_val = float("inf")

            for _ in range(size):
                node = queue.popleft()
                val = node.val

                if level % 2 == 0:
                    # 偶数层：值必须是奇数，且严格大于前一个值
                    if val % 2 == 0:
                        return False
                    if val <= prev_val:
                        return False
                else:
                    # 奇数层：值必须是偶数，且严格小于前一个值
                    if val % 2 == 1:
                        return False
                    if val >= prev_val:
                        return False

                # 更新本层的前一个值
                prev_val = val

                # 加入下一层的节点
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # 当前层处理完，进到下一层
            level += 1

        return True
```

如果你愿意，我可以下一步帮你：
- 做一两道类似的“按层约束 + BFS”的题（比如 102/103/199），巩固层序遍历；
- 或者带你快速复盘一下“层序遍历”这种模板，在面试中如何复用。
