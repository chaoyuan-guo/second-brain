# 力扣钥匙和房间题讲解

## 🧑‍💻 User

讲解力扣题目841. 钥匙和房间

---
## 🤖 Assistant

题目 841. 钥匙和房间（LeetCode 841）

---

## 一、题目快速理解（用自己的话复述）

- 有 `n` 个房间，编号 `0 ~ n-1`
- 一开始 **只有房间 0 是打开的**，其他都锁着
- 每个房间里有一些钥匙，每把钥匙可以打开某个房间
- 给你一个二维列表 `rooms`：
 - `rooms[i]` 是一个列表，里面是房间 `i` 里所有钥匙对应的房间编号
- 问：从房间 0 出发，不断拿钥匙开门，**最终能不能访问到所有房间？**

输出：`True` 或 `False`

---

## 二、本质：图的遍历 / 可达性问题

把题目抽象成图问题：

- 每个房间是一个「节点」
- 房间里的每把钥匙，就是一条「有向边」到另一个房间
 - 比如 `rooms[^1] = [2, 3]`，就表示从房间 1 有边到 2 和 3
- 房间 0 是起点
- 问：从 0 出发，能否**访问到图中的所有节点**

这就是一个典型的：**从起点进行 DFS/BFS，看能访问多少节点**。

---

## 三、解法选择：DFS / BFS 都可以

**常用面试解法**：
- 深度优先搜索（DFS）：用递归或者手动栈
- 广度优先搜索（BFS）：用队列

两者本质一样，都是「一直走所有能走到的房间」，看最后访问数是否是 `n`。

为了简单易记，我们用 **迭代 DFS + 栈**，避免递归栈深的问题，写起来也很清晰。

---

## 四、核心思路（一步一步）

1. 准备一个 `visited` 数组，长度为 `n`，表示每个房间是否已经访问过
2. 用一个栈（list 当栈），初始只压入房间 0
3. 循环：
 - 从栈中弹出一个房间 `room`
 - 如果这个房间已经访问过，就跳过
 - 否则标记为已访问
 - 把这个房间里的所有钥匙对应的房间，压入栈中
4. 循环结束后，检查 `visited` 里面是不是所有房间都为 True
 - 是：返回 `True`
 - 否：返回 `False`

### 时间复杂度

- 每个房间最多访问一次
- 每把钥匙最多处理一次
- 时间复杂度：`O(N + E)`，`N` 是房间数，`E` 是钥匙总数
这题里可以简单记：**O(总钥匙数量 + 房间数)**

### 空间复杂度

- `visited` 数组：`O(N)`
- 栈最多存放所有房间：`O(N)`
- 总空间复杂度：`O(N)`

---

## 五、面试 30 秒口述思路（可以背）

> 这题可以看成图的可达性问题：每个房间是一个节点，房间里的钥匙就是到其他房间的有向边。从 0 号房间开始做 DFS 或 BFS，一直把拿到钥匙能开的房间加入到待访问集合，用一个 visited 数组记录已经访问过的房间。遍历结束后看 visited 里是否所有房间都被访问过，如果是就返回 True，否则返回 False。时间复杂度是 O(N + E)，N 是房间数，E 是钥匙总数。

---

## 六、Python 实现（迭代 DFS，Google 风格）

```python
from typing import List


class Solution:
    """力扣 841. 钥匙和房间."""

    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        """判断是否可以访问所有房间.

        使用迭代深度优先搜索（DFS）从房间 0 开始遍历所有可达房间。
        如果最终访问到的房间数量等于总房间数，则返回 True，否则返回 False。

        Args:
            rooms: rooms[i] 表示房间 i 中所有钥匙对应的房间编号列表。

        Returns:
            bool: 如果能访问所有房间返回 True，否则返回 False。
        """
        n = len(rooms)
        # visited[i] 表示房间 i 是否被访问过
        visited = [False] * n

        # 使用栈实现迭代 DFS，初始从房间 0 开始
        stack = [0]

        while stack:
            room = stack.pop()
            if visited[room]:
                # 如果该房间已经访问过，跳过
                continue

            # 标记当前房间为已访问
            visited[room] = True

            # 将当前房间内所有钥匙对应的房间压入栈
            for key in rooms[room]:
                if not visited[key]:
                    stack.append(key)

        # 检查是否所有房间都被访问过
        return all(visited)
```

---

如果你愿意，下一步可以：
- 我给你 1～2 个变体小题（同样是图遍历/可达性），帮助你把「图遍历」这个模型彻底吃透。
