# 完全二叉树插入器题解

## 🧑‍💻 User

讲解力扣题目919. 完全二叉树插入器

---
## 🤖 Assistant

题目链接：LeetCode 919. 完全二叉树插入器（Complete Binary Tree Inserter）

---

## 一、题目简述（用自己的话）

你要实现一个数据结构 `CBTInserter`，支持：

- 初始化：给你一个**已经是完全二叉树**的根节点 `root`
- `insert(val)`：把值为 `val` 的新节点插入到这棵树中，要求插入后仍然是**完全二叉树**，返回新节点的父节点值
- `get_root()`：返回整棵树的根节点

完全二叉树的规则：
除了最后一层外，其他层都填满；最后一层从左到右依次填，不留空洞。

显然，每次插入都要找到“下一 个空位置”，也就是层序遍历（从上到下、从左到右）时遇到的第一个“孩子没满”的节点。

---

## 二、核心思路：维护一个“候选父节点队列”

### 1. 如果每次都现找，会超时

最直观的做法：

- 每次 `insert`：
 - 从根开始做一次 BFS（层序遍历）
 - 找到第一个孩子没满的节点
 - 插入在它的左/右孩子

问题：每次 `insert` 都是 O(N)，N 次插入就 O(N^2)，不划算。

### 2. 关键优化：只找一遍 + 维护队列

我们想要做到：

- 初始化时 “花一次 O(N) 的成本” 做 BFS
- 之后每次 `insert` 都 O(1)

怎么做？

**想法**：
维护一个队列 `candidates`，里面存的是：**目前“孩子还没满”的节点**，顺序按“层序遍历顺序”。

- 初始化：
 - 对整棵树做一次 BFS
 - 按层序访问节点：
 - 如果某个节点的孩子数 < 2（即：`left` 或 `right` 有空），就把它丢进 `candidates`
- 插入 `insert(val)`：
 - 队头 `parent = candidates[^0]` 就是**下一个要插入的父节点**
 - 新建 `new_node`
 - 如果 `parent.left` 为空：
 - 把新节点挂到 `parent.left`
 - 否则（说明 left 已满，只剩右）
 - 把新节点挂到 `parent.right`
 - 此时 `parent` 两个孩子都满了，从 `candidates` 队首弹出
 - 新节点本身也可能成为未来的父节点（目前 0 个孩子），所以把 `new_node` 加入 `candidates` 队尾
 - 返回 `parent.val`

- `get_root()`：直接返回保存的根 `self.root`

这样：

- 初始化：O(N)
- 每次插入：O(1)
- 空间：O(N)

---

## 三、代码实现（Python，Google 风格 + 中文注释）

> LeetCode 内部已经定义了 `TreeNode`，这里为了完整展示再写一遍。

```python
from collections import deque
from typing import Optional


class TreeNode:
    """二叉树节点定义。力扣中会直接给出这个类。"""

    def __init__(self, val: int = 0,
                 left: Optional['TreeNode'] = None,
                 right: Optional['TreeNode'] = None) -> None:
        self.val = val
        self.left = left
        self.right = right


class CBTInserter:
    """完全二叉树插入器。

    核心：维护一个队列，保存所有“孩子还没满”的节点（候选父节点），
    按层序遍历顺序排列。
    """

    def __init__(self, root: TreeNode) -> None:
        """初始化插入器，并构建候选父节点队列。

        Args:
            root: 已经是完全二叉树的根节点。
        """
        self._root = root
        # candidates 队列：存所有孩子数 < 2 的节点，按层序顺序排
        self._candidates = deque()

        # 普通的 BFS：用一个队列把整棵树走一遍
        bfs_queue = deque([root])
        while bfs_queue:
            node = bfs_queue.popleft()

            # 如果该节点的孩子数不足 2，则加入候选队列
            if not node.left or not node.right:
                self._candidates.append(node)

            # 继续层序遍历
            if node.left:
                bfs_queue.append(node.left)
            if node.right:
                bfs_queue.append(node.right)

    def insert(self, val: int) -> int:
        """插入一个新节点，保持完全二叉树性质，并返回其父节点的值。

        Args:
            val: 新插入节点的值。

        Returns:
            新插入节点的父节点的值。
        """
        new_node = TreeNode(val)

        # 队头就是下一位“要被填孩子”的父节点
        parent = self._candidates[0]

        # 先填左孩子，如果左孩子已经有了，则填右孩子
        if parent.left is None:
            parent.left = new_node
        else:
            parent.right = new_node
            # 此时 parent 左右孩子都满了，从候选队列中移除
            self._candidates.popleft()

        # 新节点未来也可能成为别人的父节点，加入候选队列末尾
        self._candidates.append(new_node)

        return parent.val

    def get_root(self) -> TreeNode:
        """返回当前树的根节点。"""
        return self._root
```

---

## 四、为什么这样做是对的（本质原因）

1. 完全二叉树的结构特征：
所有节点在一个“理想满二叉树”的数组里，是按层序连续排列的。
下一次插入的位置，必然是**层序遍历里第一个孩子没满的节点**的空位。

2. 初始化时 BFS 一次，把所有“孩子没满”的节点按层序顺序压进队列，
之后这个队列的顺序就等价于“将来插入时的父节点顺序”。

3. 插入时：
 - 队头是最早出现的、还没塞满的节点
 - 每给它添加一个孩子，它就向“更满”靠拢
 - 当它有两个孩子时，永远不会再成为插入父节点，可以出队

4. 新插入节点一定是最底层、最右边的一个节点，符合完全二叉树定义。
它现在 0 个孩子，未来可能接着长孩子，所以入队。

---

## 五、时间复杂度 & 空间复杂度

- `__init__`：对 N 个节点做一次 BFS
 - 时间：O(N)
 - 空间：O(N)
- `insert`：队头访问 + 常数次指针修改 + 队列操作
 - 时间：O(1)
 - 空间：O(1) 额外（总体仍是 O(N) 存树和队列）
- `get_root`：O(1)

在这道题的数据范围下完全够用，面试中也很漂亮。

---

## 六、面试时 30 秒口述思路要点

你可以直接按下面 3–5 句话说：

- 这题要求在完全二叉树上做插入，我的做法是维护一个队列，里面存“孩子还没满”的节点，顺序按层序遍历。
- 初始化时对整棵树做一次 BFS，遇到孩子数 < 2 的节点就进这个队列。
- 每次插入时，队头就是下一位父节点：如果它左孩子空就插左，否则插右；当左右都满了就把它从队列弹出。
- 新插入的节点本身将来可能继续当父亲，所以也加入队列尾部。
- 这样初始化是 O(N)，每次插入和 get_root 都是 O(1)，而且始终保持完全二叉树性质。

---
## 🤖 Assistant

好的，没问题。作为你的技术伙伴，我将用最直接、最易懂的方式，帮你快速掌握这道题，让你在面试中能够自信地讲出思路和写出代码。

这道题 `919. 完全二叉树插入器` 是一个非常经典的设计题，它考察的是你对**完全二叉树特性**和**队列（Queue）**这种数据结构的理解和运用。

---

### 1. 问题本质：一句话点透

面试官想考察你，能否设计一个系统，在 O(1) 的时间复杂度内，向一个完全二叉树中插入一个新节点。

关键点在于“**如何快速定位到下一个该插入的位置**”。

### 2. 核心思路：为什么要这样做？

#### 2.1 问题的难点
一个完全二叉树，新节点永远是插入在**最后一个非满节点的空位上**。比如，如果一个节点只有左孩子，那么新节点就是它的右孩子；如果一个节点左右孩子都没有，那么新节点就是它的左孩子。

如果我们每次插入（`insert`）都从根节点开始遍历（比如用 BFS 或 DFS）去寻找这个“下一个位置”，那效率太低了。树很大的时候，每次 `insert` 都要 O(N) 的时间，面试官肯定不满意。

#### 2.2 解决方案的灵感
我们想一想完全二叉树的层序遍历（BFS）顺序，它天然就是从上到下、从左到右的。而新节点的插入顺序，也恰好是这个顺序！

再想一下，哪些节点未来可以作为父节点来接收新孩子？肯定是那些**还没有满（即孩子数少于2个）**的节点。

把这两个点结合起来，我们会发现：
1. 可以成为父节点的候选者，按照层序遍历的顺序，排在最前面的那个，就是我们下一次要插入节点的父节点。
2. 当我们处理完一个父节点（比如给它添加了右孩子，它满了），它就“退休”了，下一个候选者就顶上。
3. 一个新插入的节点，它自己也立刻成为了一个“候选父节点”，排在队伍的最后面，等待未来给它分配孩子。

这个“先进先出”的候选者队伍，不就是**队列（Queue）**的特性吗？

#### 2.3 具体步骤
所以，我们的核心思路就是**用一个队列来维护所有“可以作为父节点的候选人”**。

1. **初始化 (`__init__`)**:
 * 给我们一个完整的树，我们得先把这个“候选父节点”队列准备好。
 * 怎么准备？对整棵树进行一次广度优先搜索（BFS）。
 * 在遍历过程中，把所有**孩子不满（即孩子数少于2）**的节点，按照遍历顺序加入到我们的队列中。这样，队列的头部永远是下一个要插入新节点的父节点。

2. **插入 (`insert`)**:
 * **定位父节点**：直接从队列的头部取出候选父节点（但先别急着弹出）。
 * **创建新节点**：`new_node = TreeNode(val)`。
 * **链接**：
 * 如果父节点的左孩子为空，就 `parent.left = new_node`。
 * 如果左孩子不为空，那右孩子必定为空（因为是完全二叉树），就 `parent.right = new_node`。
 * **更新队列**：
 * 新插入的 `new_node` 自己也成了一个候选父节点，把它加入队列尾部。
 * 如果刚才我们填充的是父节点的**右孩子**，说明这个父节点已经满了（光荣退休），就把它从队列头部移除。
 * **返回**父节点的值。

这个方法，初始化时需要 O(N) 遍历一次树，但之后每次 `insert` 操作都只是对队列进行 O(1) 的操作，完美解决了效率问题。

---

### 3. 面试口述思路要点 (30秒版本)

> 面试官你好，对于这道题，我的核心思路是利用一个队列来高效地找到下一次插入的位置，从而实现 O(1) 时间复杂度的插入。
>
> 1. 在**初始化**时，我会对整棵树进行一次广度优先搜索（BFS），把所有孩子不满的节点，按顺序存入一个队列中。这个队列就成了我们的“候选父节点”池。
> 2. 当**插入**新节点时，队头的节点就是新节点的父节点。我将新节点连接上去，并把这个新节点也加入队尾，因为它也成了新的候选父节点。
> 3. 如果一个父节点因为这次插入而变满了（即左右孩子都有了），我就会将它从队头移除。
>
> 这种方法避免了每次插入都重新遍历树，效率非常高。

---

### 4. 代码实现 (Python)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

import collections

class CBTInserter:
    """完全二叉树插入器。

    核心是使用一个队列来存储未来可以插入子节点的父节点。
    """

    def __init__(self, root: TreeNode):
        """初始化插入器。

        通过一次广度优先搜索（BFS）来找到所有可以成为父节点的候选节点，
        并将它们存入一个双端队列中。

        Args:
            root: 一个完全二叉树的根节点。
        """
        self.root = root
        # 使用双端队列存储可以作为父节点的候选节点
        # 这些节点的子节点数量小于2
        self.candidate_parents = collections.deque()

        # BFS 遍历树，填充 candidate_parents 队列
        q = collections.deque([self.root])
        while q:
            node = q.popleft()
            # 如果一个节点的子节点不满，它就是下一个插入操作的候选父节点
            if not node.left or not node.right:
                self.candidate_parents.append(node)
            
            # 继续遍历子节点
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)

    def insert(self, val: int) -> int:
        """向树中插入一个新节点，并返回其父节点的值。

        插入操作利用维护的 candidate_parents 队列，实现 O(1) 的时间复杂度。

        Args:
            val: 要插入的新节点的值。

        Returns:
            新插入节点的父节点的值。
        """
        # 队列的头部永远是下一个要插入新节点的父节点
        parent = self.candidate_parents[0]
        new_node = TreeNode(val)

        # 新节点总是优先成为左孩子
        if not parent.left:
            parent.left = new_node
        else:
            # 如果左孩子已存在，则成为右孩子
            parent.right = new_node
            # 此时 parent 节点已满，不再是候选父节点，将其从队列中移除
            self.candidate_parents.popleft()

        # 新插入的节点自身也成为了一个新的候选父节点
        self.candidate_parents.append(new_node)
        
        return parent.val

    def get_root(self) -> TreeNode:
        """获取当前树的根节点。

        Returns:
            树的根节点。
        """
        return self.root

# Your CBTInserter object will be instantiated and called as such:
# obj = CBTInserter(root)
# param_1 = obj.insert(val)
# param_2 = obj.get_root()
```

### 总结

这道题不难，但很巧妙。它把一个看似需要重复遍历的问题，通过一个**队列**数据结构，转化为了一个 O(1) 的操作。这体现了数据结构对算法效率的巨大提升作用。面试时能清晰地讲出这个思路演变过程（从朴素的 O(N) 想到高效的 O(1)），会非常加分。加油！
