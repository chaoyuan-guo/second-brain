# 爬楼梯动态规划思路解析

## 🧑‍💻 User

讲解力扣题目70. 爬楼梯

---
## 🤖 Assistant

题目：Leet扣 70. 爬楼梯（Climbing Stairs）

---

## 一、题目本质 & 思路

**题意**：
有一个楼梯，总共有 `n` 级台阶，每次可以爬 1 级或 2 级，问有多少种不同的爬法。

**关键本质**：
- 到第 `n` 级台阶的最后一步，要么是：
 - 从 `n-1` 级走 1 步上来
 - 从 `n-2` 级走 2 步上来
- 所以：
**到第 `n` 级的方案数 = 到 `n-1` 级的方案数 + 到 `n-2` 级的方案数**

用公式表示：
`f(n) = f(n - 1) + f(n - 2)`
初始条件：
`f(1) = 1`（只有一种：一步）
`f(2) = 2`（两种：1+1 或 2）

这就是一个标准的**斐波那契数列动态规划**问题。

---

## 二、解法设计

### 1. 为何不用简单递归？

直接写递归：

```python
def f(n):
    if n == 1 or n == 2:
        return n
    return f(n - 1) + f(n - 2)
```

- 问题：大量重复计算，时间复杂度 **O(2^n)**，面试官会认为你不了解复杂度。
- 正确方向：**动态规划 + 迭代**，把中间结果保存下来，避免重复算。

---

### 2. DP 解法（优化后：O(1) 空间）

从底往上算：

- `f(1) = 1`
- `f(2) = 2`
- 从 3 一直算到 n，每一步使用前两个值：

伪逻辑：
- `prev2` 表示 f(i-2)
- `prev1` 表示 f(i-1)
- 当前 f(i) = `prev1 + prev2`
- 然后往前滚动：
 - `prev2 = prev1`
 - `prev1 = cur`

这样就只用到了两个变量，**空间复杂度 O(1)**。

**时间复杂度**：
- 只循环一遍，O(n)

**空间复杂度**：
- 只用常数个变量，O(1)

---

## 三、Python 代码（面试可直接写）

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        """计算爬到第 n 阶楼梯的不同方法数。

        每次可以爬 1 阶或 2 阶，问总共有多少种爬法。

        算法思路：
            动态规划，令 f(n) 为爬到第 n 阶的方案数。
            则 f(n) = f(n-1) + f(n-2)，因为最后一步要么从 n-1 走 1 步，
            要么从 n-2 走 2 步。
            初始条件为 f(1) = 1, f(2) = 2。
            用两个变量迭代计算，空间优化为 O(1)。

        Args:
            n: 楼梯的总阶数。

        Returns:
            爬到第 n 阶的不同方法数。
        """
        # 边界情况处理：n 为 1 或 2 时直接返回
        if n <= 2:
            return n

        # prev2 对应 f(i-2)，prev1 对应 f(i-1)
        prev2 = 1  # f(1)
        prev1 = 2  # f(2)

        # 从第 3 阶开始迭代到第 n 阶
        for _ in range(3, n + 1):
            cur = prev1 + prev2  # 当前 f(i) = f(i-1) + f(i-2)
            # 更新前两个状态
            prev2 = prev1
            prev1 = cur

        # prev1 即为 f(n)
        return prev1
```

---

## 四、面试时 30 秒口述思路（可背）

> 这题本质是斐波那契数列。设 f(n) 是到第 n 阶的爬法数，因为每次只能走 1 或 2 阶，所以到第 n 阶的最后一步要么来自 n-1 阶走 1 步，要么来自 n-2 阶走 2 步，因此有递推关系 f(n) = f(n-1) + f(n-2)，初始值是 f(1)=1, f(2)=2。我用迭代动态规划，从 3 一直算到 n，只用两个变量保存 f(n-1) 和 f(n-2)，时间复杂度 O(n)，空间复杂度 O(1)。

---
## 🧑‍💻 User

# prev2 对应 f(i-2)，prev1 对应 f(i-1)
 prev2 = 1 # f(1)
 prev1 = 2 # f(2)
这三行给我看懵了

---
## 🤖 Assistant

这三行你懵是正常的，**问题在于注释太抽象**了，我帮你拆开，一步一步看清楚它到底在干嘛。

先把背景再说一句：

我们有递推公式：

- `f(1) = 1`
- `f(2) = 2`
- 对于 `i >= 3`：`f(i) = f(i-1) + f(i-2)`

最直接的写法是用数组：

```python
f = [0] * (n + 1)
f[1] = 1
f[2] = 2
for i in range(3, n + 1):
    f[i] = f[i - 1] + f[i - 2]
return f[n]
```

但你会发现：**每一步只用到前两个数：f(i-1), f(i-2)**
所以数组没必要存一大堆，只要存**两个变量**就行了，这就是：

```python
prev2 = 1  # f(1)
prev1 = 2  # f(2)
```

---

## 一、那句“prev2 对应 f(i-2)，prev1 对应 f(i-1)”到底啥意思？

关键点有两个：

1. for 循环是从 `i = 3` 开始的
2. 在**进入循环之前**，我们先把：
 - `prev2` 设为 `f(1)`
 - `prev1` 设为 `f(2)`

这样，**当第一次循环 i = 3 时：**

- `i - 2 = 1`，所以 `prev2` 正好就是 `f(i-2) = f(1)`
- `i - 1 = 2`，所以 `prev1` 正好就是 `f(i-1) = f(2)`

所以那句注释更严谨写应该是：

> 在后面的循环里，prev2 表示当前 i 的 f(i-2)，prev1 表示当前 i 的 f(i-1)。
> 因为第一次循环 i = 3 时，f(i-2)=f(1)，f(i-1)=f(2)，所以初始化为 1 和 2。

---

## 二、用 n = 5 具体走一遍（最容易看懂）

代码：

```python
prev2 = 1  # 一开始代表 f(1)
prev1 = 2  # 一开始代表 f(2)

for i in range(3, 6):  # i = 3,4,5
    cur = prev1 + prev2
    prev2 = prev1
    prev1 = cur
```

我们画个表，你就明白了：

### 初始状态（还没进循环）

- `prev2 = 1` 代表 `f(1)`
- `prev1 = 2` 代表 `f(2)`

---

### 第一次循环：i = 3

- 现在我们要算 `f(3)`，根据公式：`f(3) = f(2) + f(1)`
- 此时：
 - `prev1 = f(2) = 2`
 - `prev2 = f(1) = 1`

所以：

```python
cur = prev1 + prev2  # = 2 + 1 = 3，也就是 f(3)
prev2 = prev1        # prev2 变成 f(2)
prev1 = cur          # prev1 变成 f(3)
```

更新后：

- `prev2 = f(2) = 2`
- `prev1 = f(3) = 3`

---

### 第二次循环：i = 4

现在要算 `f(4) = f(3) + f(2)`

此时变量里正好有：

- `prev1 = f(3) = 3`
- `prev2 = f(2) = 2`

继续：

```python
cur = prev1 + prev2  # = 3 + 2 = 5，也就是 f(4)
prev2 = prev1        # prev2 变成 f(3)
prev1 = cur          # prev1 变成 f(4)
```

更新后：

- `prev2 = f(3) = 3`
- `prev1 = f(4) = 5`

---

### 第三次循环：i = 5

要算 `f(5) = f(4) + f(3)`

现在：

- `prev1 = f(4) = 5`
- `prev2 = f(3) = 3`

```python
cur = prev1 + prev2  # = 5 + 3 = 8，也就是 f(5)
prev2 = prev1        # prev2 = f(4)
prev1 = cur          # prev1 = f(5)
```

循环结束，`prev1 = f(5)`，直接返回。

---

## 三、换一种更“人话”的注释写法

如果当前这几行注释让你懵，可以改成这样，更符合“实际运行顺序”：

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n

        # 一开始先把 f(1) 和 f(2) 存起来
        prev2 = 1  # f(1)
        prev1 = 2  # f(2)

        # 从第 3 阶开始，一直算到第 n 阶
        for i in range(3, n + 1):
            # 当前的 f(i) = 前两阶之和 = f(i-1) + f(i-2)
            cur = prev1 + prev2

            # 状态往前滚动：
            # 下一轮循环时：
            #   prev2 要变成当前的 f(i-1)
            #   prev1 要变成当前的 f(i)
            prev2 = prev1
            prev1 = cur

        return prev1  # 最后 prev1 就是 f(n)
```

**记忆小技巧：**

- `prev1`：离当前最近的那个（i-1）
- `prev2`：离当前第二近的那个（i-2）
- 每次算出新的 `cur`（当前 i），然后：
 - 把 `prev1` 往后挪给 `prev2`
 - 把 `cur` 赋给 `prev1`

就像一个长度为 2 的“滑动窗口”一直往前滑。

---

如果你愿意，我可以下一步帮你：

1. 用这个题做“动态规划模板”的记忆总结
2. 顺着这个思路讲下一个简单 DP 题（比如「打家劫舍」）让你形成套路感
