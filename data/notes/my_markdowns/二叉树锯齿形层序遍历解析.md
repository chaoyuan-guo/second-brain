# 二叉树锯齿形层序遍历解析

## 🧑‍💻 User

讲解力扣题目103. 二叉树的锯齿形层序遍历

---
## 🤖 Assistant

**一、题目要干什么？**

给一棵二叉树，要按“层序遍历”输出每层节点的值，但方向是“锯齿形”：

- 第 0 层：从左到右
- 第 1 层：从右到左
- 第 2 层：从左到右
- …交替变化

输出类型是：`List[List[int]]`，比如：

```text
    3
   / \
  9  20
    /  \
   15   7

输出：[[3], [20, 9], [15, 7]]
```

---

**二、核心思路（一句话版）**

**正常层序遍历 + 每一层看是不是需要反转这个列表**，就能得到锯齿形顺序。

---

**三、为什么要这样做？（思路拆解）**

这题其实就是**层序遍历（广度优先遍历 BFS）**的变形：

1. **层序遍历本身：**
 - 用一个队列 `queue`
 - 每次处理“当前层”的所有节点：
 - 先记录当前队列长度 `size`，表示这一层有多少个节点
 - 循环 `size` 次，每次 `popleft()` 一个节点放入当前层列表
 - 把它的左右子节点依次加入队列，留给下一层处理

2. **加上锯齿形：**
 - 我们用一个布尔变量 `left_to_right` 表示当前层是否从左往右输出
 - 第 0 层 `left_to_right = True`
 - 下一层翻转 `left_to_right = not left_to_right`
 - 对于每一层：
 - 正常收集 `level`（左孩子先入队、右孩子后入队，不变）
 - 如果 `left_to_right` 为 `True`：直接 `res.append(level)`
 - 否则：`level.reverse()` 再加入结果

3. **为什么用“正常收集 + 可能反转”这种简单方式？**
 - 容易理解，不容易写错
 - 时间复杂度依然是 O(n)
 - 每个节点只进队、出队一次
 - 每个节点所在的那一层最多被反转一次
 - 面试官不太会纠结这种优化，反而更在意你思路清楚

（进阶写法会用 `collections.deque` 来在一层内部做 `appendleft` 减少反转，但对你当前阶段不是必须）

---

**四、时间复杂度与空间复杂度**

- 时间复杂度：**O(n)**，n 为节点数
 - 每个节点访问一次，最多被参与一次反转
- 空间复杂度：**O(n)**，队列和结果列表都最多存 O(n) 个节点

---

**五、代码（Python，带中文注释，Google Style）**

```python
from collections import deque
from typing import List, Optional


class TreeNode:
    """二叉树节点定义（力扣会自带，此处只是为了代码完整性）."""

    def __init__(self, val: int = 0, left: Optional["TreeNode"] = None,
                 right: Optional["TreeNode"] = None) -> None:
        self.val = val
        self.left = left
        self.right = right


class Solution:
    """力扣 103. 二叉树的锯齿形层序遍历."""

    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        """返回二叉树的锯齿形层序遍历结果.

        思路：
            1. 用队列做普通层序遍历（BFS）。
            2. 用布尔变量 left_to_right 表示当前层是否从左到右。
            3. 每层先按正常顺序收集，再根据 left_to_right 决定是否反转。

        Args:
            root: 二叉树根节点。

        Returns:
            各层节点值的锯齿形顺序列表。
        """
        if not root:
            return []

        result: List[List[int]] = []
        queue: deque[TreeNode] = deque([root])

        # 第 0 层从左到右
        left_to_right = True

        while queue:
            level_size = len(queue)
            level: List[int] = []

            # 处理当前层的所有节点
            for _ in range(level_size):
                node = queue.popleft()
                level.append(node.val)

                # 把下一层节点加入队列
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            # 根据当前方向决定是否反转这一层
            if not left_to_right:
                level.reverse()

            result.append(level)

            # 下一层方向取反
            left_to_right = not left_to_right

        return result
```

---

**六、面试时 30 秒口述思路要点**

> 这题本质是层序遍历加一点小变形。
> 我会用一个队列做 BFS，每次先记录当前队列长度，表示这一层有多少节点，然后把这一层的节点依次出队、加入一个临时列表，并把它们的左右孩子入队，留给下一层处理。
> 同时我维护一个布尔变量表示当前层是从左到右还是从右到左。如果是左到右，就直接把这一层的列表加入结果；如果是右到左，就把这一层的列表反转后再加入结果，然后翻转这个布尔变量。
> 这样所有节点都只访问一次，时间复杂度 O(n)，空间 O(n)。

---
## 🤖 Assistant

好的，没问题！作为你的“算法速成教练”，我们开始。

你是一名经验丰富的工程师，我们就不绕弯子，直击本质。对于这类问题，你不需要像科班学生那样去证明算法的复杂度，你需要的是 **快速理解题意，找到最直观、最符合逻辑的解法，并能清晰地表达出来**。

我们今天的目标是拿下 **力扣 103. 二叉树的锯齿形层序遍历**。

---

### 1. 题目解读

首先看题目：“锯齿形层序遍历”。

- **“层序遍历”** 是关键词。一听到“层序”、“一层一层”，你脑海里就要立刻蹦出 **BFS（广度优先搜索）** 和 **队列（Queue）**。这是固定的搭配，就像听到“键值对”就想到哈希表/字典一样。
- **“锯齿形”** 是这道题的特色。意思是，第一层从左到右，第二层从右到左，第三层再从左到右，以此类推。

所以，这道题的本质就是：**在一个标准的层序遍历框架上，增加一个方向控制**。

### 2. 核心思路分析

标准的层序遍历是怎么做的？

1. 把根节点放进队列。
2. 当队列不空时，循环：
 a. 记录下当前队列里有几个元素（`size`），这 `size` 个元素就是当前这一层的所有节点。
 b. 循环 `size` 次，把这些节点一个个从队列里拿出来，处理它（比如把值记录下来），然后把它非空的左、右孩子再放进队列。
3. 循环结束，遍历完成。

现在，我们加入“锯齿形”的需求。怎么控制方向？

最简单直接的方法就是设置一个 **“方向开关”**。

我们可以用一个布尔变量 `is_left_to_right`，初始为 `True`。

- 当 `is_left_to_right` 为 `True` 时，我们把当前层的结果 **正常（从左到右）** 存入一个临时列表。
- 当 `is_left_to_right` 为 `False` 时，我们把当前层的结果 **反过来（从右到左）** 存。
- **每处理完一层，就把这个“开关”拨一下** (`is_left_to_right = not is_left_to_right`)。

怎么实现“反过来存”呢？
最简单的方式是，先正常把这一层的所有节点值存到一个临时列表里，在准备把这个列表加入最终结果时，检查一下方向开关。如果是从右到左，**直接把这个临时列表反转一下** 就行了。

所以，我们的最终方案就是：**标准 BFS + 方向标记 + 按需反转**。

### 3. 为什么要这样做？

- **为什么用 BFS 和队列？**
 因为 BFS 的特性就是一层一层地向外探索，天然地符合“层序遍历”的要求。队列 `先进先出` 的特性保证了我们能按顺序处理完当前层的所有节点，才会开始处理下一层的节点。

- **为什么需要记录每一层的 `size`？**
 这是一个关键技巧。队列里可能同时放着第 `n` 层和第 `n+1` 层的节点。通过在每一层开始时记录下当时的队列大小 `size`，我们就能准确地知道“这一层到底有几个节点”，从而用一个 `for` 循环不多不少地恰好处理完这一整层。

- **为什么用方向标记+反转列表？**
 这是解决“锯齿形”这个特定需求最直观、代码最清晰的方法。我们把核心的遍历逻辑和方向处理逻辑解耦开。遍历只管一层层地把节点值按从左到右的顺序拿出来，方向处理只在最后一步决定这个列表要不要反转。思路清晰，不容易出错。

### 4. 口述思路要点（面试30秒版）

> “面试官你好，对于这道题，我的思路是基于广度优先搜索（BFS）来解决，因为它天然地适合处理层序遍历问题。
>
> 1. 我会使用一个队列来进行标准的层序遍历。关键技巧是在遍历每一层之前，先记录下当前队列的大小，这样就能精确地处理完一整层的节点。
> 2. 为了实现“锯齿形”的效果，我会引入一个布尔类型的方向标记，初始为从左到右。
> 3. 在每一层遍历结束后，根据这个方向标记，来决定是否需要将当前层的结果列表进行反转。
> 4. 每处理完一层，就翻转一次方向标记，为下一层做准备。
>
> 这样就能用清晰、稳定的方式完成锯齿形遍历。”

### 5. 代码实现

```python
# -*- coding: utf-8 -*-

from collections import deque
from typing import List, Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def zigzag_level_order(root: Optional[TreeNode]) -> List[List[int]]:
    """对二叉树进行锯齿形层序遍历。

    Args:
        root: 二叉树的根节点。

    Returns:
        一个列表的列表，表示锯齿形层序遍历的结果。
    """
    if not root:
        # 处理边界情况：如果树为空，直接返回空列表
        return []

    # 最终返回的结果列表
    results = []
    # 使用双端队列(deque)作为辅助数据结构，效率比 list 作为队列高
    queue = deque([root])
    # 方向标记，True 表示从左到右，False 表示从右到左
    is_left_to_right = True

    # 当队列中还有节点时，持续遍历
    while queue:
        # 获取当前层的节点数量
        level_size = len(queue)
        # 用一个临时列表存储当前层的所有节点值
        current_level = []

        # 遍历当前层的所有节点
        for _ in range(level_size):
            # 从队列左侧弹出一个节点
            node = queue.popleft()
            current_level.append(node.val)

            # 将下一层的节点（子节点）加入队列
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        # 核心：根据方向标记决定是否反转当前层的结果
        if not is_left_to_right:
            current_level.reverse()
        
        # 将处理好的当前层结果加入最终结果列表
        results.append(current_level)

        # 切换方向，为下一层做准备
        is_left_to_right = not is_left_to_right

    return results

# --- 你可以在本地这样测试 ---
# if __name__ == '__main__':
#     # 构建一个示例树: [3, 9, 20, null, null, 15, 7]
#     #     3
#     #    / \
#     #   9  20
#     #     /  \
#     #    15   7
#     root = TreeNode(3)
#     root.left = TreeNode(9)
#     root.right = TreeNode(20)
#     root.right.left = TreeNode(15)
#     root.right.right = TreeNode(7)
#
#     # 期望输出: [[3], [20, 9], [15, 7]]
#     print(zigzag_level_order(root))
#
#     # 构建另一个示例树: [1, 2, 3, 4, null, null, 5]
#     #       1
#     #      / \
#     #     2   3
#     #    /     \
#     #   4       5
#     root2 = TreeNode(1)
#     root2.left = TreeNode(2)
#     root2.right = TreeNode(3)
#     root2.left.left = TreeNode(4)
#     root2.right.right = TreeNode(5)
#
#     # 期望输出: [[1], [3, 2], [4, 5]]
#     print(zigzag_level_order(root2))

```

**总结一下关键点：**

1. **模板化**：层序遍历就是 `while queue` + `for _ in range(len(queue))` 这个固定模板。
2. **抓重点**：这道题的重点是在模板之上，增加一个 `is_left_to_right` 标志位。
3. **简单化**：用 `list.reverse()` 来处理方向问题，简单直接，面试时足够了。

这道题是二叉树题目里的经典款，掌握它，你对 BFS 的理解就能上一个台阶。加油！有任何不清楚的地方，随时可以追问。
