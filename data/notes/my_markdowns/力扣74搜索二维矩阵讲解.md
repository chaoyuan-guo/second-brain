# 力扣74搜索二维矩阵讲解

## 🧑‍💻 User

讲解力扣题目74. 搜索二维矩阵

---
## 🤖 Assistant

**题目：LeetCode 74. 搜索二维矩阵**

---

## 1. 题目和条件理解

给你一个 `m x n` 的整数矩阵 `matrix`，和一个整数 `target`。

矩阵有两个非常重要的性质（这是解题关键）：

1. 每一行从左到右是升序排列的
2. 每一行的第一个数 **都大于** 前一行的最后一个数

第二条很重要，它意味着：

> 整个矩阵如果按行依次展开，就是一个 **完全递增的有序一维数组**。

例子：
```text
[
  [1, 3, 5, 7],
  [10,11,16,20],
  [23,30,34,60]
]
```

展开后等价于一维有序数组：
```text
[1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]
```

任务：判断 `target` 是否在矩阵中，返回 `True / False`。

---

## 2. 解法核心思路：当成一维有序数组做二分查找（推荐）

### 核心想法（为什么可以这样做）

因为矩阵满足上面两个条件，所以按行从左到右展开后，整体是 **严格递增的一维有序数组**。
既然是一维有序数组，就可以直接用 **二分查找**，时间复杂度 `O(log(m*n))`。

但真实数据是二维的，我们要解决的是：

> 一维下标 `mid` 如何映射回二维的 `(row, col)`？

假设矩阵有 `m` 行 `n` 列：

- 一维索引范围是 `0 ~ m*n - 1`
- 对应二维坐标关系：
 - `row = mid // n`（整除，确定是第几行）
 - `col = mid % n`（取模，确定是该行第几列）

这样就能在二分查找时，用一个 `mid` 索引定位到矩阵中的某个元素。

### 二分查找基本步骤

1. 设定左边界 `left = 0`，右边界 `right = m * n - 1`
2. 循环：当 `left <= right` 时：
 - 取中点：`mid = (left + right) // 2`
 - 映射到矩阵：
 `row = mid // n`, `col = mid % n`
 - 比较 `matrix[row][col]` 与 `target`：
 - 若相等，返回 `True`
 - 若当前值 < 目标值，说明目标在右半部分，`left = mid + 1`
 - 若当前值 > 目标值，说明目标在左半部分，`right = mid - 1`
3. 循环结束还没找到，返回 `False`

### 时间 / 空间复杂度

- 时间复杂度：`O(log(m*n))`
- 空间复杂度：`O(1)`（只用了常数级变量）

---

## 3. 面试时的 30 秒口述思路（可以背）

> 这个矩阵每一行有序，而且每一行的第一个元素都大于上一行的最后一个元素，所以按行展开以后，整体就是一个严格递增的一维有序数组。
> 我把它当成长度为 m*n 的一维数组做二分查找，下标 mid 对应的行列是：row = mid // n，col = mid % n。
> 每次用 mid 映射到 matrix[row][col] 和 target 比较，小了就移动左边界，大了就移动右边界，直到找到或者区间为空。
> 时间复杂度是 O(log(m*n))，空间是 O(1)。

---

## 4. Python 代码（Google Style + 中文注释）

```python
from typing import List


class Solution:
    """在二维有序矩阵中搜索目标值。

    矩阵满足：
    1. 每行从左到右升序
    2. 每行第一个元素 > 前一行最后一个元素
    """

    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        """判断目标值是否存在于矩阵中。

        思路：
        - 利用矩阵的特殊有序性，将整个矩阵视为一维有序数组，
          直接对 [0, m*n-1] 做二分查找。
        - 一维索引 mid 映射为二维坐标：
          row = mid // n, col = mid % n

        时间复杂度：O(log(m*n))
        空间复杂度：O(1)

        Args:
            matrix: 二维整数矩阵。
            target: 需要查找的目标值。

        Returns:
            若目标值存在于矩阵中返回 True，否则返回 False。
        """
        if not matrix or not matrix[0]:
            # 处理空矩阵情况
            return False

        m = len(matrix)        # 行数
        n = len(matrix[0])     # 列数

        left, right = 0, m * n - 1

        while left <= right:
            mid = (left + right) // 2
            # 将一维索引映射回二维坐标
            row = mid // n
            col = mid % n
            value = matrix[row][col]

            if value == target:
                return True
            elif value < target:
                left = mid + 1
            else:
                right = mid - 1

        return False
```

---

如果你愿意，我可以下一步给你一道非常类似但稍微变形的题来巩固：**240. 搜索二维矩阵 II**（只有行列各自有序，没有“整体展开有序”）。这两题一起掌握，对“有序矩阵 + 二分 / 双指针”这一类题会非常有帮助。

---
## 🤖 Assistant

好的，没问题！作为你的“算法速成教练”，我将帮你用最高效、最直接的方式掌握这道题，让你在面试中能清晰地讲出来。

我们来分析一下 **力扣 74. 搜索二维矩阵**。

### 1. 题目本质分析：为什么要用这种方法？

我们先看题目给的两个条件：
1. 每行从左到右递增。
2. 下一行的第一个数比上一行的最后一个数大。

请你把这两个条件合并成一句话，会发现什么？

**“如果把这个二维矩阵从第一行开始，一行一行地拼接起来，它就是一个完整的、有序的一维数组！”**

比如下面这个矩阵：
```
[
  [1,  3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 60]
]
```
拉平成一维就是： `[1, 3, 5, 7, 10, 11, 16, 20, 23, 30, 34, 60]`。

看到了吗？一个**有序数组**。面试官一问“在一个有序数组里查找一个数”，你的肌肉记忆应该立刻告诉你：**二分查找**！

这就是这道题的本质：**它就是一个伪装成二维矩阵的、对“二分查找”的考察。** 你的任务就是识破这个伪装。

### 2. 面试口述思路要点 (30秒版本)

> 面试官你好，对于这道题，我的思路是这样的。
>
> 首先，我观察到这个矩阵的两个特性决定了它在宏观上是整体有序的，如果把它看作一个一维数组，它就是排好序的。
>
> 因此，我可以不把它当作二维矩阵，而是看作一个长度为 `m * n` 的虚拟一维数组，然后在这个虚拟数组上进行一次标准的“二分查找”。
>
> 查找的关键在于，如何将一维数组的中间点索引 `mid` 映射回二维矩阵的行列坐标。这个映射关系很简单：`行 = mid // 总列数`，`列 = mid % 总列数`。
>
> 这样，通过不断比较目标值和中间值，缩小搜索范围，就能以 O(log(m*n)) 的时间复杂度找到目标。

这个思路清晰、直接，体现了你透过现象看本质的能力。

### 3. 代码实现 (Python)

我们直接用上面“一次二分查找”的思路来写代码。

```python
from typing import List

def search_matrix(matrix: List[List[int]], target: int) -> bool:
  """在一个特殊的二维矩阵中搜索目标值。

  该方法将二维矩阵视为一个虚拟的一维有序数组，并对其应用二分查找。

  Args:
    matrix: 一个 m x n 的整数矩阵，满足每行有序且下一行首元素大于上一行尾元素。
    target: 要搜索的目标整数。

  Returns:
    如果目标值存在于矩阵中，则返回 True，否则返回 False。
  """
  # 处理边界情况，如果矩阵为空或行/列为空，直接返回 False
  if not matrix or not matrix[0]:
    return False

  rows, cols = len(matrix), len(matrix[0])
  # 定义虚拟一维数组的左右边界
  left, right = 0, rows * cols - 1

  while left <= right:
    # 计算中间索引
    mid = (left + right) // 2
    
    # 核心：将一维的 mid 索引映射回二维的坐标 (row, col)
    # 行坐标 = mid // 总列数
    # 列坐标 = mid % 总列数
    mid_value = matrix[mid // cols][mid % cols]

    if mid_value == target:
      return True
    elif mid_value < target:
      # 目标值在右半部分，移动左边界
      left = mid + 1
    else:
      # 目标值在左半部分，移动右边界
      right = mid - 1
  
  # 循环结束都没找到，说明不存在
  return False

# --- 示例 ---
matrix1 = [
    [1, 3, 5, 7],
    [10, 11, 16, 20],
    [23, 30, 34, 60]
]
target1 = 3
print(f"在矩阵中查找 {target1}: {search_matrix(matrix1, target1)}")  # 输出: True

target2 = 13
print(f"在矩阵中查找 {target2}: {search_matrix(matrix1, target2)}")  # 输出: False
```

### 4. 速成总结

1. **看到“有序” -> 想到“二分查找”**：这是算法题最重要的直觉之一。
2. **识别问题本质**：这道题的核心是识别出它是一个“伪装的”一维有序数组。
3. **降维打击**：把二维坐标问题转化为一维索引问题，是解决这类问题的常用技巧。关键是掌握 `row = index // cols` 和 `col = index % cols` 这个映射关系。
4. **时间复杂度**：暴力搜索是 O(m*n)，而二分查找是 O(log(m*n))，这是质的飞跃，也是面试官想听到的。

记住，你不是要去发明算法，而是要在有限的时间内，识别出这是哪种经典问题的变体，然后套用最高效的经典解法。这道题就是二分查找的经典应用，掌握它，你的算法水平就实实在在地前进了一步。继续加油！
