# 乘积最大子数组题目讲解

## 🧑‍💻 User

讲解力扣题目152. 乘积最大子数组

---
## 🤖 Assistant

**一、题目大意（LeetCode 152. 乘积最大子数组）**

给定一个整数数组 `nums`（可包含正数、负数和 0），
要找出一个**连续子数组**，使得该子数组元素乘积最大，返回这个最大乘积。

---

## 二、核心思想：一边走一边维护「最大乘积」和「最小乘积」

### 1. 为什么这题不能直接用“最大子段和”的思路？

最大子段和（Kadane）里，只要维护一个当前最大和就够了。
但在乘积问题中，**负数会“翻转”大小关系**：

- 一个很大的正数 × 负数 → 很小（变负）
- 一个很小的负数 × 负数 → 变成很大的正数

因此，如果当前数是负数，**之前的“最小乘积”反而可能变成新的最大乘积**。

---

### 2. 关键点：同时维护 `max_prod` 和 `min_prod`

遍历数组，对每个元素 `x`：

- `max_prod`：以当前位置结尾的**最大乘积**
- `min_prod`：以当前位置结尾的**最小乘积**（通常是负数，但很重要）

对当前元素 `x` 有三种候选：

1. `x` 自己单独开一个新子数组
2. 之前的 `max_prod * x`
3. 之前的 `min_prod * x`（如果 `x` 是负的，这个可能变最大）

**常用写法：**

- 如果 `x < 0`，先交换 `max_prod` 和 `min_prod`（因为乘负数会翻转）
- 然后：
 - `max_prod = max(x, max_prod * x)`
 - `min_prod = min(x, min_prod * x)`
- 用全局 `ans` 更新最大值：`ans = max(ans, max_prod)`

**0 会怎样？**

- 当 `x = 0` 时：
 - `max_prod = max(0, max_prod * 0) = 0`
 - `min_prod = min(0, min_prod * 0) = 0`
- 等价于从 0 重新开始一个新子数组，逻辑自然处理，不用特判。

---

### 3. 时间 / 空间复杂度

- 时间复杂度：`O(n)`，只遍历一遍
- 空间复杂度：`O(1)`，常数额外变量

---

## 三、代码实现（Python，含中文注释）

```python
from typing import List


class Solution:
    """力扣 152. 乘积最大子数组."""

    def maxProduct(self, nums: List[int]) -> int:
        """返回数组中连续子数组的最大乘积.

        思路：
        - 一边遍历，一边维护：
          - max_prod: 以当前元素结尾的最大乘积
          - min_prod: 以当前元素结尾的最小乘积（可能是负数）
        - 遇到负数时，max_prod 和 min_prod 角色互换（乘负数会翻转大小关系）
        - 每一步用 max_prod 更新全局最大值 ans

        Args:
            nums: 整型数组，可包含正数、负数和 0，长度至少为 1。

        Returns:
            连续子数组的最大乘积。
        """
        # 初始化：以第一个元素作为起点
        max_prod = nums[0]  # 当前以 nums[i] 结尾的最大乘积
        min_prod = nums[0]  # 当前以 nums[i] 结尾的最小乘积
        ans = nums[0]       # 全局最大乘积

        for x in nums[1:]:
            # 如果当前数是负数，最大和最小会互换，先交换
            if x < 0:
                max_prod, min_prod = min_prod, max_prod

            # 更新当前位置结尾的最大/最小乘积
            # 两种选择：单独以 x 开始，或者接在之前的乘积后面
            max_prod = max(x, max_prod * x)
            min_prod = min(x, min_prod * x)

            # 更新全局最大值
            ans = max(ans, max_prod)

        return ans
```

---

## 四、面试中 30 秒口述思路要点（可直接复述）

> - 这是最大乘积的连续子数组，难点在于负数会翻转大小关系。
> - 我一边遍历数组，一边维护两个值：
> - `max_prod`：以当前元素结尾的最大乘积
> - `min_prod`：以当前元素结尾的最小乘积
> - 如果当前数是负数，`max_prod` 和 `min_prod` 先交换，因为乘负数会把最大的变最小、最小的变最大。
> - 然后对当前数 `x`，`max_prod = max(x, max_prod * x)`，`min_prod = min(x, min_prod * x)`，用 `max_prod` 更新全局答案。
> - 0 的情况会自然被处理，相当于重新开始。整体时间复杂度 O(n)，空间 O(1)。

---
## 🤖 Assistant

好的，没问题！作为你的“算法速成教练”，我们现在开始。你的背景非常典型，很多经验丰富的工程师在算法上都有短板，但这完全可以快速弥补。我们的目标不是成为算法大神，而是在面试中清晰地讲出思路，并写出正确的代码。

对于 **力扣 152. 乘积最大子数组** 这道经典的动态规划（DP）题目，我们开始剖析。

---

### 1. 问题分析与直觉

**题目：** 给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组，并返回该乘积。

**例子：**
* 输入: `[2, 3, -2, 4]`
* 输出: `6` (因为子数组 `[2, 3]` 的乘积是 6)

* 输入: `[-2, 0, -1]`
* 输出: `0` (结果不能是 2，因为 `[-2, -1]` 不是连续子数组)

**核心难点：**
这题和它的“兄弟”题目「最大子数组和」不一样。在求和问题中，遇到负数只会让总和变小。但在乘积问题中，**负数是“搅局者”也是“破局者”**。一个负数会让当前的最大值变成最小值，但也可能让当前的最小值（一个很大的负数）在遇到下一个负数时，摇身一变，成为一个巨大的正数。

比如 `[-1, -10]`，单独看 `-1` 最大乘积是 `-1`，但遇到 `-10` 后，`(-1) * (-10) = 10`，变成了最大值。

### 2. 为什么要这样做？（问题的本质）

正是因为负数的存在，我们不能只盯着“最大乘积”。在任何一步，我们都必须同时关注两件事：

1. **到目前为止的最大乘积是多少？** （我们期望它是一个正数）
2. **到目前为止的最小乘积是多少？** （我们期望它是一个负数，因为它有潜力在下一步乘以一个负数，从而“翻身”成为最大值）

所以，解题的关键思路就是：在遍历数组的每一步，我们都要同时维护和更新**“以当前元素结尾的最大乘积”**和**“以当前元素结尾的最小乘积”**。

这就是这道题动态规划思想的精髓。

### 3. 面试口述思路要点 (30秒版本)

> 面试官你好，对于这道题，我的思路是使用动态规划。
>
> 这道题和“最大子数组和”的关键区别在于负数的存在。一个负数乘以负数会得到正数，所以一个当前的“最小乘积”（负数）可能在下一步变成“最大乘积”。
>
> 因此，在遍历数组时，我需要同时维护两个变量：`max_so_far`（以当前元素结尾的最大乘积）和 `min_so_far`（以当前元素结尾的最小乘积）。
>
> 每一步更新这两个值时，新的最大值可能来自「上一步的最大值 * 当前数」，「上一步的最小值 * 当前数」，或者「当前数本身」这三者中的最大者。最小值同理。
>
> 我会用一个全局变量 `result` 来记录整个过程中出现过的最大乘积，就是最终答案。这个算法只需要一次遍历，时间复杂度是 O(n)，空间复杂度是 O(1)。

### 4. Python 代码实现

这部分你可以直接背下来，并理解其中的逻辑。

```python
# 遵循 Google Python Style Guide

def max_product(nums: list[int]) -> int:
    """计算数组中乘积最大的非空连续子数组。

    Args:
        nums: 一个整数数组。

    Returns:
        数组中乘积最大的连续子数组的乘积。
    """
    # 处理边界情况，如果数组为空，没有子数组。
    if not nums:
        return 0

    # 初始化
    # max_so_far: 以当前元素结尾的最大乘积
    # min_so_far: 以当前元素结尾的最小乘积
    # result: 全局最大乘积
    # 三者都初始化为数组的第一个元素
    max_so_far = nums[0]
    min_so_far = nums[0]
    result = nums[0]

    # 从第二个元素开始遍历
    for i in range(1, len(nums)):
        num = nums[i]

        # 核心：更新 max_so_far 和 min_so_far
        # 在更新 max_so_far 之前，需要保存旧的 max_so_far 用于计算新的 min_so_far
        # 因为它们是同时更新的，或者说，这一轮的更新依赖上一轮的状态
        temp_max = max(num, max_so_far * num, min_so_far * num)
        min_so_far = min(num, max_so_far * num, min_so_far * num)
        max_so_far = temp_max
        
        # 另一种更 Pythonic 的写法，避免使用临时变量：
        # candidates = (num, max_so_far * num, min_so_far * num)
        # max_so_far = max(candidates)
        # min_so_far = min(candidates)

        # 更新全局最大值
        result = max(result, max_so_far)

    return result

# --- 测试用例 ---
# 例子1
nums1 = [2, 3, -2, 4]
print(f"输入: {nums1}, 输出: {max_product(nums1)}")  # 预期输出: 6

# 例子2
nums2 = [-2, 0, -1]
print(f"输入: {nums2}, 输出: {max_product(nums2)}")  # 预期输出: 0

# 例子3 (包含负负得正的关键)
nums3 = [-2, 3, -4]
# 过程:
# i=0: max_so_far=-2, min_so_far=-2, result=-2
# i=1 (num=3): max_so_far=max(3, -2*3, -2*3)=3, min_so_far=min(3, -6, -6)=-6, result=max(-2, 3)=3
# i=2 (num=-4): max_so_far=max(-4, 3*-4, -6*-4)=max(-4, -12, 24)=24, min_so_far=min(-4, -12, 24)=-12, result=max(3, 24)=24
print(f"输入: {nums3}, 输出: {max_product(nums3)}")  # 预期输出: 24

```

### 总结与速成要点

1. **一句话记住核心**：遇到乘积问题，要警惕**负数**。
2. **一套组合拳**：动态规划，同时维护 **最大值（`max_so_far`）** 和 **最小值（`min_so_far`）**。
3. **三个候选人**：每一步的新状态，都由 `上一步最大值 * 当前值`、`上一步最小值 * 当前值`、`当前值本身` 这三个候选值决定。
4. **一个全局变量**：别忘了用一个 `result` 变量来打擂台，保留住整个过程中的历史最大值。

这道题是动态规划中的经典入门题，但它考察的思维转换非常巧妙。搞懂它，你对动态规划的理解就能上一个台阶，达到“六七十分”的目标就近了一大步。加油！

---
## 🧑‍💻 User

再讲一下力扣198. 打家劫舍

---
## 🤖 Assistant

**一、题目大意（LeetCode 198. 打家劫舍）**

一排房子，每个房子里有一定数量的钱 `nums[i]`，
你是小偷，不能偷相邻的两家，问最多能偷到多少钱。

---

## 二、核心思想：经典一维动态规划

### 1. 抽象成选择问题

对每一间房子 `i`，你只有两种选择：

- **偷第 i 家**：那就不能偷第 i-1 家
- **不偷第 i 家**：那第 i-1 家随便（偷或不偷），取 i-1 之前的最优

所以“前 i 间房子的最大收益”可以写成一个状态。

---

### 2. 状态定义与转移公式

设 `dp[i]` 表示：**从前 i 间房子（下标 0..i）中能偷到的最大金额**。

对第 i 间房（下标 i）：

- 如果不偷第 i 家：收益是 `dp[i-1]`
- 如果偷第 i 家：收益是 `dp[i-2] + nums[i]`（因为相邻不能偷，只能加上 i-2 的最优）

两者取最大：

```text
dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
```

**边界条件：**

- 只有一间房：`dp[^0] = nums[^0]`
- 两间房：`dp[^1] = max(nums[^0], nums[^1])`

然后从 i = 2 一直算到 n-1。

---

### 3. 空间优化

注意到转移公式只用到了 `dp[i-1]` 和 `dp[i-2]`，
不需要整个数组，只需两个变量：

- `prev2` 表示 `dp[i-2]`
- `prev1` 表示 `dp[i-1]`

循环更新即可：

```text
cur = max(prev1, prev2 + nums[i])
然后 prev2 = prev1, prev1 = cur
```

复杂度：

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

---

## 三、代码实现（Python，含中文注释）

```python
from typing import List


class Solution:
    """力扣 198. 打家劫舍."""

    def rob(self, nums: List[int]) -> int:
        """返回在不能偷相邻房子的前提下，能偷到的最大金额.

        动态规划思路：
        - 定义 dp[i] 为偷前 i 间房子（下标 0..i）能获得的最大金额。
        - 对第 i 间房（下标 i）有两种选择：
          1) 不偷：收益为 dp[i - 1]
          2) 偷：收益为 dp[i - 2] + nums[i]
        - 状态转移：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        - 只依赖前两个状态，可用两个变量滚动保存，降为 O(1) 空间。

        Args:
            nums: 每间房子的钱数列表。

        Returns:
            能偷到的最大金额。
        """
        n = len(nums)
        if n == 0:
            return 0
        if n == 1:
            return nums[0]

        # prev2 对应 dp[i - 2]，prev1 对应 dp[i - 1]
        prev2 = nums[0]
        prev1 = max(nums[0], nums[1])

        for i in range(2, n):
            # 当前房子 i 的最优选择：偷或不偷
            cur = max(prev1, prev2 + nums[i])
            prev2, prev1 = prev1, cur

        return prev1
```

---

## 四、面试中 30 秒口述思路要点（可直接用）

> - 这是典型的动态规划题。设 `dp[i]` 为前 i 间房能偷到的最大金额。
> - 对第 i 间房有两种选择：
> - 不偷：收益是 `dp[i-1]`
> - 偷：那前一间不能偷，收益是 `dp[i-2] + nums[i]`
> - 所以转移方程是 `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`。
> - 用两个变量分别保存 `dp[i-1]` 和 `dp[i-2]` 就能做到 O(1) 空间，整体时间 O(n)。

---
## 🤖 Assistant

好的，我们来讲解另一道动态规划的入门经典题：**打家劫舍**。这道题是学习动态规划思想的绝佳案例。

---

**一、题目大意（LeetCode 198. 打家劫舍）**

你是一个小偷，计划偷窃沿街的房屋。每间房内都有一定金额的现金。
有一个限制：**不能偷窃相邻的房屋**。
给定一个非负整数数组 `nums`，代表每间房的金额，计算你在不触发警报的情况下，能偷到的最高总金额。

---

## 二、核心思想：做选择，然后取最优

### 1. 为什么是动态规划（Dynamic Programming, DP）？

- **最优子结构**：偷到第 `i` 间房的最高金额，依赖于偷到第 `i-1` 或 `i-2` 间房的决策结果。
- **重叠子问题**：计算后面的结果时，会反复用到前面的计算结果。

简单来说，就是“**今天的最优解，是由昨天的某些最优解推导出来的**”。

### 2. 关键点：每间房只有两种选择

当我们站在第 `i` 间房门口时，思考一个问题：**这间房，我偷还是不偷？**

1. **偷（Rob）**：
 - 如果我偷了第 `i` 间，根据规则，我就**不能偷**第 `i-1` 间。
 - 那我能获得的总金额就是：**`nums[i]`（当前这间的钱） + 到第 `i-2` 间为止能偷到的最高金额**。

2. **不偷（Don't Rob）**：
 - 如果我不偷第 `i` 间，那我的人身安全就和第 `i-1` 间无关了。
 - 我能获得的总金额就是：**到第 `i-1` 间为止能偷到的最高金额**。

**决策**：在这两种选择中，我肯定选能拿到更多钱的那一种。
所以，**到第 `i` 间为止的最高金额 = `max(偷第 i 间, 不偷第 i 间)`**

### 3. 从 DP 数组到 O(1) 空间优化

- **DP 数组思路**：
 - 我们可以创建一个 `dp` 数组，`dp[i]` 表示偷到第 `i` 间房为止的最高金额。
 - 状态转移方程就是：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`

- **空间优化**：
 - 观察上面的公式，我们发现计算 `dp[i]` 时，只用到了 `dp[i-1]` 和 `dp[i-2]` 这两个值。
 - 这意味着我们根本不需要一个完整的数组来存储所有历史结果，只需要两个变量来记录“前一间”和“前前一间”的最高金额即可。

 - 我们用 `prev` 和 `curr` 两个变量：
 - `prev`：相当于 `dp[i-2]`
 - `curr`：相当于 `dp[i-1]`
 - 遍历数组，每一步都计算出新的 `curr`，然后更新 `prev` 和 `curr`，滚动前进。

### 4. 时间 / 空间复杂度

- 时间复杂度：`O(n)`，只遍历一遍数组。
- 空间复杂度：`O(1)`，因为我们只用了两个额外变量（优化后）。

---

## 三、代码实现（Python，含中文注释）

```python
from typing import List


class Solution:
    """力扣 198. 打家劫舍."""

    def rob(self, nums: List[int]) -> int:
        """计算不偷相邻房屋能获得的最大金额.

        思路（动态规划 + 空间优化）:
        - 遍历房屋列表，对每间房 i，都有两种选择：偷或不偷。
        - 1. 偷：金额 = 当前房的钱 + 到 i-2 房为止的最大金额。
        - 2. 不偷：金额 = 到 i-1 房为止的最大金额。
        - 我们取两者的最大值。
        - 这个过程只依赖前两个状态，所以用两个变量 prev 和 curr 滚动更新即可。

        Args:
            nums: 非负整数数组，代表每间房的金额。

        Returns:
            能偷到的最高总金额。
        """
        # prev: 记录到 i-2 房为止的最大金额
        # curr: 记录到 i-1 房为止的最大金额
        prev, curr = 0, 0

        for money in nums:
            # 计算到当前房为止的最大金额
            # temp 临时存储上一个 curr 的值，也就是到 i-1 房的最大金额
            temp = curr

            # 核心决策：
            # - 不偷当前房 (money)，最大金额就是 curr (到上一房为止的最大金额)
            # - 偷当前房 (money)，最大金额就是 prev (到上上房为止的最大金额) + money
            curr = max(curr, prev + money)

            # 更新 prev，为下一次迭代做准备
            prev = temp

        return curr

```

---

## 四、面试中 30 秒口述思路要点（可直接复述）

> - 这是一个典型的动态规划问题。对于每一间房，我都有“抢”或“不抢”两种选择。
> - 如果不抢当前这间，那么最大金额就是到前一间为止能抢到的最大金额。
> - 如果抢当前这间，那么金额就是当前房的钱，加上到“前前一间”为止能抢到的最大金额。
> - 我在遍历时，只需要维护这两个值，然后取它们的最大值来更新。这样就能用两个变量滚动计算，把空间复杂度从 O(n) 优化到 O(1)，时间复杂度是 O(n)。
